[{"title":"CCD测光流程","url":"/2020/05/20/2021-CCD%E6%B5%8B%E5%85%89%E6%B5%81%E7%A8%8B/","content":"测光流程1、观测方案\n根据题目条件，采用较差测光，选取标准星\n由于被测星与标准星的天光背景是不一样的，在后续的数据处理中要扣除\n在观测中的视场会足够大，所以一次曝光就可以得到星像及其附近的天光。为提高测量精度，对其多帧采集。在观测过程中需要拍平场和暗场。\n\n\n2、数据预处理\n去掉热点、死点和宇宙线的影响\n\n平场、暗场的处理：\n有效数据 = \\frac{观测数据 - 暗场}{平场数据 - 暗场}\n有效数据中已经包含了待测星和对应的天光亮度信息，记待测星为，标准星为.\n\n\n\n3、较差测光原理\\triangle m = m_{V_A}-m_{v_R}= -2.5\\lg(\\frac{待测星-天光}{标准星-天光})4、天光的计算​    星像处的天光与其附近的相同，从星的有效数据中选取一块没有星像的方形区域。计算该区域的亮度和面积，可以得到每像元的天光亮度。再乘以星斑所占的像元个数，最终得到星像斑中所含的天光亮度，记为$E{A_S}，同理标准星像斑中的天光亮度为E{R_S}$。\n5、星像的视亮度计算m_{V_A} = m_{V_R} - 2.5\\lg(\\frac{E_A-E_{A_S}}{E_R-R_{R_S}})归算到大气外：采用公式\n","categories":["Photometry"],"tags":["CCD"]},{"title":"方差、标准差和均方根误差的区别","url":"/2020/12/08/2021-RMS/","content":"方差、标准差和均方根误差的区别一、方差\n方差(variance)：是在概率论和统计方差衡量随机变量或一组数据离散程度的度量。概率论中方差用来度量随机变量和其数学期望(及均值)之间的偏离程度。统计中的方差(样本方差)是各个数据分别与其平均是之差的平方的和的平均数。\n公式表示：对于一组随机变量或者统计数据，其期望值我们由表示，即随机变量或统计数据的均值，然后对各个数据与均值的差的平方求和：，最后对它们再求期望值就得到了方差公式。\n\n​        D(X) = E\\left\\{\\sum[X-E(X)]^2\\right\\} \n这个公式描述了随机变量或统计数据与均值的偏离程度。\n\n二、方差与标准差\\sigma = \\sqrt{\\frac{1}{N}\\sum\\limits_{i-1}^{N}(x_i-\\mu)^2}根号里的内容就是我们刚提到的方差：\nD(X) = E\\left\\{\\sum[X-E(X)]^2\\right\\}\n那么问题来了，既然有了方差来描述变量与均值的偏离程度，那又搞出来个标准差干什么呢？原因是：方差与我们要处理的数据的量纲是不一致的，虽然能很好的描述数据与均值的偏离程度，但是处理结果是不符合我们的直观思维的。\n\n三、均方差、均方根误差\n标准差（Standard Deviation），中文环境中又常称均方差，但不同于均方根误差（meansquared error，均方根误差是各数据偏离真实值的距离平方和的平均数开方，也即误差平方和的平均数开方，计算公式形式上接近标准差，它不开方叫均方误差，均方误差和方差形式上接近），标准差是数据偏离均值的平方和平均后的方根，用σ表示，标准差是方差的算术平方根。 \n从上面定义我们可以得到以下几点： \n1、均方差就是标准差，标准差就是均方差；\n\n2、均方根误差不同于均方差；\n\n3、均方根误差是各数据偏离真实值的距离平方和的平均数的开方；\n\n举个例子：我们要测量房间里的温度，很遗憾我们的温度计精度不高，所以就需要测量5次，得到一组数据[x1,x2,x3,x4,x5],假设温度的真实值是x，数据与真实值的误差e=x-xi 。\n\n那么均方误差 \n\n均方根误差的公式一般为：\n\n总的来说，均方差（标准差）是数据序列与均值的关系，而均方根误差是数据序列与真实值之间的关系。因此，标准差是用来衡量一组数自身的离散程度，而均方根误差是用来衡量观测值同真值之间的偏差，它们的研究对象和研究目的不同，但是计算过程类似。\nhttps://blog.csdn.net/zengxiantao1994/article/details/77855644\n\n\n","categories":["Math"],"tags":["RMS"]},{"title":"Java笔记","url":"/2021/02/21/2021-Java-Note/","content":"Java学习笔记一\nJava主类结构Java语言是面向对象的程序设计语言，Java程序的基本组成单元是类，类体中又包括属性与方法两部分。每个应用程序都必须包含一个main()方法，含有main()方法的类称为主类。\n包声明一个Java应用程序是由若干个类组成的，package为包的关键字。\n声明成员变量和局部变量通常将类的属性称为类的全局变量（成员变量），将方法中的属性称为局部变量。全局变量声明在类体中，局部变量声明在方法体中。\n编写主方法main()方法为类体中的主方法，该方法从“{”开始，至”}”结束。public、static和void分别是main()方法的权限修饰符、静态修饰符、和返回值修饰符，Java程序中的main()方法必须声明为public static void。main()方法是程序开始执行的位置。\n导入API类库在Java语言中可以通过import关键字导入相关的类。\nJava基本数据类型在Java中有8种基本数据类型来存储数值、字符和布尔值，\n\n\n布尔类型又称逻辑类型，通过关键字boolean来定义布尔类型变量，只有true和false两个值，分别代表布尔逻辑中的“真”和“假”。布尔值不能与整数类型进行转换。布尔类型通常被用在流程控制中作为判断条件。\n\n变量与常量\n常量：其值不能被改变的量称为常量\n变量：其值能被改变的量称为变量\n\n标识符和关键字\n标识符：标识符可以简单地理解为一个名字，用来标识类名、变量名、方法名、数组名、文件名的有效字符序列。Java语言规定标识符由任意顺序的字母、下划线(_)、美元符号($)和数字组成，并且第一个字符不能是数字。标识符不能是Java中的保留关键字、标识符区分大小写。\n关键字：关键字是Java语言中已经被赋予特定意义的一些单词，不可以把这些字作为标识符来使用。\n\n\n\n\n\nint\npublic\nthis\nfinally\nboolean\nabstract\n\n\n\n\ncontinue\nfloat\nlong\nshort\nthrow\nthrows\n\n\nreturn\nbreak\nfor\nstatic\nnew\ninterface\n\n\nif\ngoto\ndefault\nbyte\ndo\ncase\n\n\nstrictfp\npackage\nsuper\nvoid\ntry\nswitch\n\n\nelse\ncatch\nimplements\nprivate\nfinal\nclass\n\n\nextends\nvolatile\nwhile\nsynchronized\ninstanceof\nchar\n\n\nprotected\nimport\ntransient\ndafault\ndouble\n\n\n\n\n","categories":["Java学习笔记"],"tags":["Java"]},{"title":"DECal一个波长的校准步骤","url":"/2022/05/12/2021-DECal%E4%B8%80%E4%B8%AA%E6%B3%A2%E9%95%BF%E7%9A%84%E6%A0%A1%E5%87%86%E6%AD%A5%E9%AA%A4/","content":"DECal一个波长的校准步骤\n从关闭DECal的光源开始。\n\n暗图像采集。\n\n拍摄DECam图像，这将用于监视和消除圆顶中的背景光水平。\n在DECam曝光期间获取光电二极管数据。\n\n\n打开DECal光源。\n\n\nLight图像采集。\n\n拍摄DECam图像，这是校准数据。\n在DECam图像曝光期间获取光电二极管数据。\n\n\n关闭DECal光源。\n\n将光源调到下一个波长。\n\n重复以上步骤知道到达扫描波长的末端。\n\n\n此过程从DECam生成每个波长和滤光片的一系列交替的“light”和“dark”图像，以及一系列“light”和“dark”光电二极管数据。通过以下步骤获取望远镜的最终透光率。\n\n在曝光时间内对光电二极管信号进行积分以获得校准光电二极管看到的光子总数。光电二极管信号针对波长、温度、放大器增益进行校正。通过从light图像中的光子数中减去在该波长之前和之后拍摄的两个暗区的平均光子数，输出是减去背景的净光子数。\nDECam图像的原理相同：从亮图像中减去相邻的两个暗图像的平均值，得到净光图像。\n每个波长的透光率是通过净光图像除以光电二极管上的净光子数获得的。这为我们提供了每个滤波器在每个波长下每个像素的透光率。\n\n","categories":["Photometry"],"tags":["DECal"]},{"title":"Matplotlib","url":"/2020/05/19/2021-Matplotlib/","content":"Matplotlib\n使用matplotlib.pyplot(plt)进行绘图时，有两种方法：\n\n直接使用plt里的函数\n使用面向对象的方法，先产生一个Axes对象，再对此对象进行操作，实现绘图\n\n\n第二种方法可以实现更多操作，具有更好的定制性。基于此方法绘图时，需要理解以下概念：\n\nFigure：画布，Axes容器\nAxes：坐标系，绘图的区域，绘图总是在坐标系上进行；\nAxis：坐标轴，x轴或y轴。\n\n\n\n\n\nMatplotlib Figure的各个部分\n使用Axes的用法import matplotlib.pyplot as pltplt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]  # 中文字体设置-黑体plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False  # 解决保存图像是负号&#x27;-&#x27;显示为方块的问题x = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(x)y2 = np.cos(x)fig = plt.figure(figsize = (10,6))# ax = fig.add_subplot(111)  ax1, ax2 = fig.subplots(1,2)  # 上面两行代码可以合并为一行，fig, (ax1,ax2) = plt.subplots(1,2, figsize = (10,6))ax1.plot(x, y1, label=&#x27;$sinx$&#x27;)  #ax1.plot(x, y2, label=&#x27;$cosx$&#x27;)ax1.legend(loc=&#x27;upper right&#x27;)ax1.set_xlim(-2 * np.pi - 1, 2 * np.pi + 3)ax1.set_xticks([-2 * np.pi, -np.pi, 0, np.pi, 2 * np.pi])ax1.set_xticklabels([&#x27;$-2\\pi$&#x27;, &#x27;$-\\pi$&#x27;, &#x27;$0$&#x27;, &#x27;$\\pi$&#x27;, &#x27;$2\\pi$&#x27;])ax1.set_title(&#x27;三角-函数&#x27;)ax1.set_xlabel(&#x27;横坐标&#x27;)ax1.set_ylabel(&#x27;纵坐标&#x27;)ax1.axhline(y=0, c=&#x27;black&#x27;)ax1.axvline(x=0, c=&#x27;black&#x27;)# 绘制矩阵灰度图# 这里的matshow也可以换做imshow, 效果一样# matshow只能绘制矩阵, imshow可以绘制矩阵(2维) RGB(3维) RGBA(4维图片)图像ax2.matshow(np.random.randint(0, 255, (12, 12)), vmin=0, vmax=255, cmap=&#x27;gray&#x27;)ax1.set_xticks([])ax1.set_yticks([])ax1.set_title(&quot;mat show&quot;)# 设置父标题(画布标题),字体大小，字体粗细(bold:加粗)fig.suptitle(&quot;Axes绘图示例&quot;, fontsize = 14, fontweight = &#x27;bold&#x27;) plt.show()\n\nimport matplotlib.pyplot as plt fig = plt.figure()fig.suptitle(&#x27;bold figure suptitle&#x27;, fontsize=14, fontweight=&#x27;bold&#x27;)ax = fig.add_subplot(111)fig.subplots_adjust(top=0.85)ax.set_title(&#x27;axes title&#x27;)ax.set_xlabel(&#x27;xlabel&#x27;)ax.set_ylabel(&#x27;ylabel&#x27;)ax.text(3, 8, &#x27;boxed italics text in data coords&#x27;, style=&#x27;italic&#x27;,        bbox=&#123;&#x27;facecolor&#x27;:&#x27;red&#x27;, &#x27;alpha&#x27;:0.5, &#x27;pad&#x27;:10&#125;)ax.text(2, 6, r&#x27;an equation: $E=mc^2$&#x27;, fontsize=15)# ax.text(3, 2, unicode(&#x27;unicode: Institut f\\374r Festk\\366rperphysik&#x27;, &#x27;latin-1&#x27;))ax.text(0.95, 0.01, &#x27;colored text in axes coords&#x27;,        verticalalignment=&#x27;bottom&#x27;, horizontalalignment=&#x27;right&#x27;,        transform=ax.transAxes,        color=&#x27;green&#x27;, fontsize=15)ax.plot([2,3,4], [1,2,5], &#x27;o&#x27;)ax.annotate(&#x27;annotate&#x27;, xy=(2, 1), xytext=(3, 4),            arrowprops=dict(facecolor=&#x27;black&#x27;, shrink=0.05))ax.axis([0, 10, 0, 11])plt.show()\n\nsubplot和subplotsmatplotlib.pyplot.subplot\n调用subplot函数后，如下所示，创建一个nrows行，ncols列的Axes对象，然后返回在index位置的子图。\n\n添加子图\nsubplot(nrows, ncols, index, facecolor, polar, **kwargs)\n\nnrows, ncols, index: 如果这三个数都小于10，则可以连写，2,2,2\n\nfacecolor: string型，如’b’, ‘w’等，这是子图的背景。\npolar: bool类型，默认为False, 设置坐标是否为极坐标。\n\n\n当然，如果想要对子图操作更加严格，按照网格来画，可以选择使用GridSpec。 import matplotlib.gridspec as gridspec,\n\n\nmatplotlib.pyplot.subplots\nsubplots函数会返回一个figure对象和一个Axes对象：\ndef subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True,             subplot_kw=None, gridspec_kw=None, **fig_kw):\n\nnrows and cols: 行和列的个数\nsharex and sharey：决定是否共享x轴或y轴\n**fig_kw: figure函数的参数都可以，如figsize、facecolor等。\n\nfig,axes = plt.subplots(2,2)axes[0,0].plot(t1, np.exp(-t1) * np.cos(2 * np.pi * t1), &#x27;r-&#x27;, label = &#x27;line&#x27;)axes[0, 0].locator_params(nbins=10)     #控制x、y轴的标注位置，此处只用来控制标注个数axes[0, 0].set_xlabel(&#x27;x-label&#x27;, fontsize=fontsize)  #设置x轴的标签axes[0, 0].set_ylabel(&#x27;y-label&#x27;, fontsize=fontsize)  #设置y轴的标签axes[0, 0].set_title(&#x27;Title&#x27;, fontsize=fontsize)     #设置该子图的标题axes[0, 0].legend()                                  #添加图例axes[0,1].plot(t2, np.cos(2 * np.pi * t2), &#x27;r--&#x27;)axes[1,1].plot([1, 2, 3, 4], [1, 4, 9, 16])plt.show()\n\n\n稍加修饰plt.tight_layout(),可以解决各个子图标签、标题相互遮挡等问题\nplt.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)\n\npad: 分数(相对于font-size)，控制各个子图边界或figure边界的内边距。\nh_pad and w_pad: 单位为英寸，控制相邻子图的高或者宽的边距。\n\n","categories":["Python"],"tags":["Mtaplotlib"]},{"title":"astrometry","url":"/2021/02/12/2021-astrometry/","content":"安装Astrometry.net官方教程\n\n系统准备\nyum install出现Loaded plugins: fastestmirror, langpacks\n1、修改插件配置文件\nvi /etc/yum/pluginconf.d/fastestmirror.conf\n将enable=1改为enable=0\n2、修改yum配置文件\n# vi /etc/yum.conf\n将plugins=1改为plugins=0\n然后yum clean all yum makecache\n\n\nGNU build tools \n\nsudo yum install cairo-1.15.12-4 cairo-devel-1.15.12-4 libpng-1.5.13-7 libpng-devel-1.5.13-7 libjpeg-turbo-1.2.90-8 libjpeg-turbo-devel-1.2.90-8 zlib-1.2.7-18 zlib-devel-1.2.7-18 bzip2-libs-1.0.6-13 bzip2-devel-1.0.6-13 python-2.7.5-86 numpy-1.7.1-13\n\nPython 3\n\nsudo yum -y install python3 python3-devel python3-pipsudo pip3 install numpysudo pip3 install astropy\n\nNetPBM\n\nsudo yum -y install netpbm netpbm-devel netpbm-progs\n\npyfits and cfitsio\n\nsudo yum -y install epel-releasesudo yum -y install pyfits pyfits-tools cfitsio cfitsio-devel\n\n安装g++ gcc\n\nsudo yum -y install gcc gcc-c++ kernel-devel\nBuilding astrometry.netwget http://astrometry.net/downloads/astrometry.net-0.80.tar.gztar zxvf astrometry.net-0.80.tar.gzcd astrometry.net-0.80/util/# Edit 'makefile.netpbm'# NETPBM_INC ?= -I/usr/include/netpbm# NETPBM_LIB ?= -L/usr/lib64 -lnetpbmcd ..makemake pymake extrasudo make install#配置环境变量export PATH=${PATH}:/usr/local/astrometry/bin\n","categories":["Photometry"],"tags":["astrometry.net"]},{"title":"math_markdown","url":"/2020/12/08/2021-math-markdown/","content":"Markdown Cheat Sheet数学相关LaTeX表达前言后面介绍的内容是排版的数学符号的内容，不止一次有人强调中文版的Wikipedia并不是英文版内容的翻译，并不是。可以对比下参考部分的两个页面，我觉得中文页面做的不错，这两个页面里面关于垂直，貌似有那么点不同。\n\n表 1: 数学模式重音符\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\hat{a}\n\n\\check{a}\n\n\\tilde{a}\n\n\\acute{a}\n\n\n \n\\grave{a}\n \n\\dot{a}\n \n\\bar{a}\n\n\\ddot{a}\n\n\n \n\\vec{a}\n \n\\widehat{A}\n\n\\widetilde{A}\n\n\\breve{a}\n\n\n\n\n\n\\hat{A}\n\n\\tilde{A}\n\n\n\n\n\n表2: 小写希腊字母\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\alpha\n\n\\theta\n\n\\upsilon\n\no\n\n\n\n\\beta\n\n\\vartheta\n\n\\pi\n\n\\phi\n\n\n\n\\gamma\n\n\\iota\n\n\\varpi\n\n\\varphi\n\n\n\n\\delta\n\n\\kappa\n\n\\rho\n\n\\chi\n\n\n\n\\epsilon\n\n\\lambda\n\n\\varrho\n\n\\psi\n\n\n\n\\varepsilon\n\n\\mu\n\n\\sigma\n\n\\omega\n\n\n\n\\zeta\n\n\\nu\n\n\\varsigma\n\n\\nabla\n\n\n\n\\eta\n\n\\xi\n\n\\tau\n\n\n\n\n\n表 3: 大写希腊字母\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\Gamma\n\n\\Lambda\n\n\\Sigma\\mit\\Sigma\n\n\\Psi\n\n\n\n\\Delta\n\n\\Xi\n\n\\Upsilon\n\n\\Omega\\mit\\Omega\n\n\n\n\\Theta\n\n\\Pi\n\n\\Phi\n\n\n\n\n\n表 4: 数学字母\n\n\n\n示例\n代码\n\n\n\n\n\n\\mathbf {ABCdefxyzXYZ123}\n\n\n\n\\mathrm {ABCdefxyzXYZ123}\n\n\n\n\\mathit {ABCdefxyzXYZ123}\n\n\n\n\\mathcal {ABCdefxyzXYZ123}\n\n\n𝒹ℯ𝒻𝓍𝓎𝓏\n\\mathscr {ABCdefxyzXYZ123}\n\n\n\n\\mathfrak {ABCdefxyzXYZ123}\n\n\n𝕕𝕖𝕗𝕩𝕪𝕫𝟙𝟚𝟛\n\\mathbb {ABCdefxyzXYZ123}\n\n\n\n\\boldsymbol{ABCdefxyzXYZ123}\n\n\n\n\n表 5: 运算符与函数\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\sum\n\n\\prod\n\nx\\cdot{y}\n\n\n\n\\bigcup\n\n\\bigoplus\n\nx\\times {y}\n\n\n\n\\bigvee\n\n\\bigcap\n$\\left\\\nw\\right\\\n$\n**\\left\\\n\n\n\n\\bigwedge\n\n\\biguplus\n\n\\iiint\n\n\n\n\\bigotimes\n\n\\oint\n\n\\iint\n\n\n\n\\int x\\,{\\rm d}x\n\n\\bigsqcup\n\n\\lgroup \\rgroup\n\n\n\n\\coprod\n\n\\bigodot\n\n\\partial\n\n\n\n\\det\n\n\\max\n\n\\min\n\n\n\n\\log\n\n\n\n\n\n\n\n表 6: 常用箭头\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\leftarrow\n\n\\rightarrow\n\n\\leftrightarrow\n\n\n\n\\longleftarrow\n\n\\longrightarrow\n\n\\longleftrightarrow\n\n\n\n\\Leftarrow\n\n\\Rightarrow\n\n\\Leftrightarrow\n\n\n\n\\Longleftarrow\n\n\\Longrightarrow\n\n\\Longleftrightarrow\n\n\n\n\\uparrow\n\n\\downarrow\n\n\\updownarrow\n\n\n\n\n表 7: 其他常用符号\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\therefore\n\n\\because\n\n\\min \\limits_{f \\in {H}}\n\n\n\n\\leqslant\n\n\\geqslant\n\n\\equiv\n\n\n\n\\thickapprox\n\n\\thicksim \\sim\n\n\\left(\\frac{A}{B}\\right)\n\n\n\n\\neq\n\n\\in\n\n\\hat{=}\n\n\n\n\\pm\n\n\\sqrt{a}\n\n\\geq \\leq\n\n\n\n\\perp\n\n\\angle\n\n\\varpropto\n\n\n\n\\infty\n\ng^\\prime\n\n\\forall\n\n\n\n\\exist\n\n\\bot\n\n\\top\n\n\n\n\n注意\\bot和\\perp的区别，垂直是\\perp\n表8: 使用字体\n\n\n\n示例\n代码\n备注\n\n\n\n\n\n\\rm {ABCdefXYZ123}\n罗马体\n\n\n\n\\it{ABCdefXYZ123}\n意大利体\n\n\n\n\\bf{ABCdefXYZ123}\n正粗体，黑体\n\n\n\n\\cal {ABCdefXYZ123}\n花体\n\n\n\n\\sf{ABCdefXYZ123}\n等线体\n\n\n\n\\mit{ABCdefXYZ123}\n数字斜体\n\n\n\n\\tt{ABCdefXYZ123}\n打印机字体\n\n\n\n\n表9: 分段函数与公式对齐分段函数示例\n\nf(x,y) = \\begin{cases}\n1 & x与y满足某一事实\\\\\n0 & 否则\n\\end{cases}# 代码f(x,y) = \\begin{cases}1 &amp; x与y满足某一事实\\\\0 &amp; 否则\\end{cases}\n\n\\begin{aligned}\nL(w)&=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\&=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\n\\end{aligned}对齐控制# 代码# 通过\\begin{aligned}\\end{aligned}控制对齐, 使用&amp;表示对齐点.\\begin{aligned}L(w)&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\\end{aligned}\n另外注意到前面的分段函数自动变好了，但是上面多行对齐的公式没有自动编号，如果需要自动编号，外面嵌入equation\n\n\\begin{equation}\n\\begin{aligned}\nL(w)&=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\n\\end{aligned}\n\\end{equation}代码如下\n\\begin{equation}\\begin{aligned}L(w)&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\\end{aligned}\\end{equation}\n公式编号关于编号也可以通过行间公式做如下表达\n\n\\begin{align}\nL(w)&=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\nonumber\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\n\\end{align}代码如下\n\\begin{align}L(w)&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\nonumber\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\\end{align}\n以上代码有两点需要注意体会：\n\nalign\n\\nonumber的使用\n\n表X: 矩阵普通矩阵\n\\begin{aligned}\nM_1(x)=\n\\begin{bmatrix}\n&a_{01}&a_{02}\\\\\n&0&0\n\\end{bmatrix}\n&,M_2(x)=\n\\begin{bmatrix}\n&b_{11}&b_{12}\\\\\n&b_{21}&b_{22}\n\\end{bmatrix}\n\\\\\nM_3(x)=\n\\begin{bmatrix}\n&c_{11}&c_{12}\\\\\n&c_{21}&c_{22}\n\\end{bmatrix}\n&,M_4(x)=\n\\begin{bmatrix}\n&1&0\\\\\n&1&0\n\\end{bmatrix}\n\\end{aligned}\\begin{aligned}M_1(x)=\\begin{bmatrix}&amp;a_{01}&amp;a_{02}\\\\&amp;0&amp;0\\end{bmatrix}&amp;,M_2(x)=\\begin{bmatrix}&amp;b_{11}&amp;b_{12}\\\\&amp;b_{21}&amp;b_{22}\\end{bmatrix}\\\\M_3(x)=\\begin{bmatrix}&amp;c_{11}&amp;c_{12}\\\\&amp;c_{21}&amp;c_{22}\\end{bmatrix}&amp;,M_4(x)=\\begin{bmatrix}&amp;1&amp;0\\\\&amp;1&amp;0\\end{bmatrix}\\end{aligned}\n带省略符号的Matrix\nX^\\mathrm T=\n\\left[\n\\begin{matrix}\n x_{11} & \\cdots & x_{1N}       \\\\\n \\vdots & \\ddots & \\vdots         \\\\\n x_{M1} & \\cdots & x_{MN}       \\\\\n\\end{matrix}\n\\right]% 这里稍微注意下转置符号， 《统计学习方法》中的转置用的是正体的T% 可以参考 https://zhuanlan.zhihu.com/p/27490955 中关于转置写法的讨论。X^\\mathrm T=\\left[\\begin{matrix} x_{11} &amp; \\cdots &amp; x_{1N}       \\\\ \\vdots &amp; \\ddots &amp; \\vdots \t\t\\\\ x_{M1} &amp; \\cdots &amp; x_{MN}       \\\\\\end{matrix}\\right]\n向量\n\\left[\n\\begin{array}\n\\\\2\n\\\\3\n\\end{array}\n\\right]\\left[\\begin{array}\\\\2\\\\3\\end{array}\\right]\n\n\\overbrace{abcde}\\underbrace{fghij}_{comment}\\overline{klmn}\\underline{opqr}\\overleftarrow{stuv}\\overrightarrow{wxyz}\\overbrace{abcde}\\underbrace{fghij}_{comment}\\overline{klmn}\\underline{opqr}\\overleftarrow{stuv}\\overrightarrow{wxyz}\nEmoji表XI: Emoji\n\n\n\n:smirk: smirk\n:smile:smile\n:laughing:laughing\n:blush:blush\n:smiley:smiley\n:heart_eyes:heart_eyes\n\n\n\n\n😘kissing_heart\n:wink:wink\n:kissing:kissing\n:confused:confused\n:sweat:sweat\n:joy:joy\n\n\n:sob:sob\n:cry:cry\n:angry:angry\n:yum:yum\n:mask:mask\n:sunglasses:sunglasses\n\n\n:heartpulse:heartpulse\n:alien:alien\n:cupid:cupid\n:+1:+1\n:cn:cn\n:shit:shit\n\n\n\n\nRefs\nMarkdown 数学符号速查\nCmd Markdown公式指导手册\nEquals_Sign\nEmoji\nShort Math Guide for LaTeX\nList of Mathematical Symbols\n数学公式\nMatplotlib Math Text\n\n","categories":["Markdown"],"tags":["Markdown"]},{"title":"Pandas 使用","url":"/2020/05/19/2021-Pandas-%E4%BD%BF%E7%94%A8/","content":"Pandas 使用import numpy as npimport pandas as pd csv_file = &#x27;data.csv&#x27;csv_data = pd.read_csv(csv_file,low_memory = False) #防止弹出警告df = pd.DataFrame()print(df.shape) # 查看数据维度print(df.duplicated()) #查看重复值print(pd.isnull(df)) #查看缺失值#将NAN值替换为0 pd.fillna 填补缺失值 df.where()df.where(df.notnull(),0) \n\npandas绘图import pandasimport numpy as npfrom pandas import Series,DataFrameimport matplotlib.pyplot as pltimport matplotlibmatplotlib.style.use(&#x27;gplot&#x27;)\nimport pandas as pdrng = pd.period_range(&#x27;2016-03&#x27;,&#x27;2016-12&#x27;,freq=&#x27;M&#x27;)print(rng)PeriodIndex([&#x27;2016-03&#x27;, &#x27;2016-04&#x27;, &#x27;2016-05&#x27;, &#x27;2016-06&#x27;, &#x27;2016-07&#x27;, &#x27;2016-08&#x27;,             &#x27;2016-09&#x27;, &#x27;2016-10&#x27;, &#x27;2016-11&#x27;, &#x27;2016-12&#x27;],            dtype=&#x27;period[M]&#x27;, freq=&#x27;M&#x27;)\n","categories":["Python"],"tags":["Pandas"]},{"title":"望远镜的性能描述","url":"/2020/05/20/2021-%E6%9C%9B%E8%BF%9C%E9%95%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%8F%E8%BF%B0/","content":"光学天文望远镜1、望远镜的性能描述\n通光孔径\n\n通光孔径是指光可以通过的望远镜的直径，通过的光亮和直径的平方成正比\n\nD/d = F/f = m，m称为放大倍数，在没有光损的前提下，光束所覆盖的面积减少到倍，故所观测到的强度是原来的倍，这就是天文望远镜的作用。收的光更多，看得更远。\n\n\n\n\n\n角分辨力\n\n理论上望远镜的分辨力是由它的口径决定的，如果口径为D，则分辨角( ——波长)。这个公式对射电望远镜同样适用。\n\n但在光学波段，当口径大到约10cm以后，由于大气视宁度的限制，地面望远镜口径增大并不能提高分辨力，如图2.2所示，在(Frield参量)之后，分辨力是不变的，完全由视宁度决定，当然，如果用自适应光学，则可以达到或接近望远镜的理论分辨力。\n\n\n\n\n底片比例尺\n\n如图2-3所示，在天空成一定角度的的两个天体，在焦面上的像有一定的距离,一般把称为比例尺(Scale)，单位通常用表示.\n\n显然，.为望远镜焦距(单位为)，故比例尺  \n现在CCD普遍使用，很多人直接用每个像元多少角秒代替比例尺。设像元大小为(单位)，则该CCD的比例尺为\n\n比例尺 = \\frac{206265k}{1000f}(''/像元)\n\n\n焦比（相对口径）\n\n焦距和口径之比称为望远镜的焦比，即 或叫数，甚至直接叫，比如，也有人写成，即焦距是口径的15倍。\n\n它的倒数叫相对口径，。\n\n在焦面上，像的照度\nJ = ID^2/f^2 = I/F^2 = IA^2——入射光的照度  \n——反映在探测器上每个像元上的能量的一个很重要的量  \n越小，越大，速度越快；反之，越大，速度越慢。在用多通道做成像观测时(如CCD或照相底片等)是重要因素。但对于单通道(如单通道光电倍增管，或射电望远镜)，只取决于。\n\n\n\n视场\n\n能被望远镜良好成像的天空区域的角直径称为望远镜的视场\n所谓良好成像是指无晕，且像质达到要求。\n视场大的望远镜(比如折射望远镜和折反射望远镜，视场可达。左右)比较适合巡天和普查工作\n视场小的望远镜(如反射望远镜，视场一般不超过。)适合个别天体的精细观测研究。\n但在CCD普遍代替照相底片的今天，往往是探测器的尺寸限制了望远镜的使用视场。\n\n\n贯穿本领\n\n即常说的极限星等，更严格的是观测型星的极限星等。\n\n\n光能集中度\n\n上面这些性能是望远镜的整体参数，而衡量一架望远镜光学质量的最重要的指标叫做光能集中度，即扣除视宁度的影响后，点源天体的光在焦面上的能量分布，通俗的说即星象的大小。\n\n\n\n2、折射望远镜\n折射望远镜的光路\n天体的光经折射镜在焦平面聚焦，由于制造的原因，典型的焦比在15左右。\n主要优点是，视场较大、焦距比较长、比例尺大，适合测量恒星的精确位置。\n折射望远镜对温度的变化不敏感，光学调整好后可以维持很多年不需重调。\n折射望远镜的视场可以达到几度，很适合进行天体自行等方面的研究。\n世界上最大的折射望远镜只有1(美国Wisconsin的Yerkes天文台)\n限制折射望远镜尺寸的原因有\n第一、折射镜的支撑在边上，而最厚的中间部分没有支撑，自身重力的影响使镜面产生变形。\n第二、典型焦比为15，所以相应的镜筒长，观测室大，从而造价增加。\n第三，对短波吸收厉害，到近紫外几乎无法观测。\n\n\n\n3、反射望远镜1、反射望远镜的可用焦点\n主焦点：主镜的焦点。只用凹面反射主镜成像，探测器在主镜前。主焦点的焦比在1.5~4，速度快、光损小、视场较大，但探测器有部分挡光，操作也不太方便。\n\n牛顿焦点：为克服主焦点的缺点，在主镜焦点前放一块和光轴成。的反射镜，将主焦点的光引到镜筒外成像，方便操作，一切参数和用主焦点一样。\n\n卡塞格林焦点：在主镜和主焦点之间，放置一个凸形反射镜(称副镜或第二境)，组成双反射镜系统，两镜的光轴重合。光线在副镜反射后穿过主镜的中心孔，聚焦于主镜反射面的背后，这个焦点称为卡塞格林焦点，简称卡式焦点或卡焦。经典卡塞格林系统的主镜为抛物面，副镜是双曲面。现代的卡塞格林系统是Ritchey-Chretien(简称R-C)系统，其主镜和副镜均为准双曲面形，克服了传统卡焦系统的球差和慧差，视场明显加大；由于副镜是凸镜，使焦距加长，一般的为7~15，焦距称为等值焦距，使从主镜反射面到焦点的光路长度远比等值焦距短，从而镜筒和观测室的尺寸大为减小。\n\nNasmyth焦点：也称耐焦，卡焦在主镜后面，安装终端设备的空间和重量都受到一定的限制。为此，仿照牛顿焦点，用一块和光轴成。的平面反射镜，置于主镜和副镜之间，将卡焦的光转到Nasmyth平台(一个或两个)，平台和望远镜同步绕垂直轴旋转(所以是用于地平式机架)，那里可以放更重、更大的设备。所有参数的优缺点与卡焦的一样，最大的区别在于视场中的像的旋转的。\n\n折轴焦点：也称Coudé焦点。其副镜也是凸镜，但其曲率半径比卡焦副镜的小，凸的更厉害，因此其等值焦距更长，一般的在20~40左右，视场更小，大多为几个弧分。\n\n\n\n\n卡焦、Nasmyth焦点和折轴焦点都有副镜，其功能是加长焦距，设系统的焦距是，主镜的焦距是,则称为副镜的放大率。\n由于地球的自转，天体都有周日运动，所以在位置固定的Nasmyth焦点，或是Coudé焦点，都有视场旋转问题。观测单个点源，则没有什么关系。但如果观测面天体，或者观测多个天体(比如星团、星云、彗星)，或者观测一个天区，一定要让被测对象的像在焦面上相对于探测器的位置是固定的。有两种途径解决：用光学方法或者机械方法抵消视场的旋转；让探测器和视场同步旋转。\n\n","categories":["Astrophysical Techniques"],"tags":["Telescope"]},{"title":"BRDF双向反射分布函数","url":"/2022/05/17/BRDF%E5%8F%8C%E5%90%91%E5%8F%8D%E5%B0%84%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/","content":"BRDF（双向反射分布函数）在计算机图形学领域，着色（Shading）是指根据表面或者多边形相对光源和相机的角度和距离来计算它的颜色的过程。不同的用途可以使用不同的着色算法，CAD等追求响应速度的交互式图形领域可以使用简单快速的着色算法，卡通油画等艺术效果可以使用非真实感（Nonphotorealistic）着色算法，而追求真实感的CG电影或游戏则可以使用基于物理建模的着色算法。\n本文关注基于物理着色的BRDF模型，希望能将BRDF的来龙去脉讲清楚，并分析Cook-Torrance BRDF公式的推导过程。本人水平有限，如有错误，请不吝指教。\n要模拟真实光照，我们先要弄清光照的现象。\n\n光照现象光由光子组成，光子既具有粒子的特性，又表现出波的特性。从波的角度看，光是电磁波的一种，不同频率（波长）的光波能量不同，频率越高（波长越短），能量越高，频率越低（波长越长），能量越低，其中波长在380nm－780nm范围内的光波能被人类的视网膜感知到，这个范围的光波称为可见光，不同频率的可见光被人感知为不同的颜色，频率越高的光偏蓝，频率较低的光则偏红。\n\n光学根据研究的尺度可以分为波动光学（Wave Optics）和几何光学（Geometric Optics），波动光学比几何光学复杂，而由于图形学领域关注的尺度远大于可见光的波长（380nm－780nm），也很少涉及光的偏振、干涉和衍射等波动光学才能解释的现象，所以我们一般用几何光学来建立光照模型。\n光学平面边界上的散射我们在中学物理课上学过光学平面边界的散射。\n\n平面边界两边物质的折射率（Refractive Index）不同，当一束光线从一种物质照射到平面边界上时，其中一部分在平面边界被反射回这种物质，反射方向为入射方向关于平面法线的对称向量：\nr_i = 2(n \\cdot l) n - l\n其中是反射向量，是光线入射向量，是平面法线\n向量间的表示向量的点积，两个单位向量的点积等于它们夹角的余弦。\n\n另一部分光穿过平面边界折射进入另一种物质，折射方向可由Snell法则（Snell’s Law）计算得出：\n\\frac{\\sin \\theta_i}{\\sin \\theta_t} = \\frac{v_i}{v_t} = \\frac{\\lambda_i}{\\lambda_t} = \\frac{n_t}{n_i}\n其中下标 表示入射介质，下标 表示折射介质， 表示光线相当于边界法线的角度，表示介质中的光速，表示介质中的波长，表示介质的折射率。\n\n反射和折射的比例由菲涅尔方程(Fresnel Equations)给出，菲涅尔方程比较复杂，图形学里一般使用近似公式计算。\n非光学平面上的散射现实世界中的表面绝大多数都是凹凸不平的，尽管这种凹凸不平小于肉眼可见的尺度，但远大于光线的波长。在这种情况下，可以把表面看成是大量朝向各异的微小光学平面的集合，我们肉眼可见的每个点都包含了很多个这样的微小光学平面。\n光线照射到这些微小表面上时，同样一部分在表面发生反射。这些朝向不同的微表面把入射光线反射到不同的方向。\n\n从上图可以看出表面粗糙程度对光线反射方向的影响。上面的物体表面相对光滑，微表面朝向差别较小，反射光线的方向差别也比较小，表面反射环境的图像比较锐利。下面的物体表面比较粗糙，微表面朝向差别大，反射光线的方向差别也比较大，表面反射环境的图像比较模糊。\n另一部分光线发生折射，折射光线何去何从取决于物质的组成成分。\n对于玻璃等透明物质，光线穿透玻璃，在另一边再次发生反射折射，图形学用双向透射分布函数BTDF来模拟这种现象，以后有机会再写。下面我们看看不透明和半透明物质。\n对于金属，折射进表面的光线的能量会立即被金属中的自由电子吸收，转换成电子的能量，不再可见（下图左边）。对于非金属（电介质或绝缘体），它们往往不是由单一成分构成，而可以认为其中包含了很多折射率不同的微粒，光线遇到这些粒子后发生反射折射，在物质内部不断传播，散射到不同方向，其中一部分会再次穿过表面被观察到，这种现象称为次表面散射（Subsurface Scattering，下图右边穿出表面的蓝色光线），也有一部分在传输过程中被吸收。\n\n根据物质属性和观察尺度的不同，次表面散射会表现出不同的效果。\n如下面的左上图，如果光线在物质中传播距离小于观察尺度（绿色区域，可以认为是一个像素区域），我们看到情况如下面的右上图，入射点、反射点、次表面散射的出射点看起来是同一个点。其中反射部分（图中浅棕色出射光）就是我们常说的高光（Specular Light），常聚集在一个方向周围，向这个方向观察该点会看到明显的高光，从其他方向观察该点时高光则比较微弱；次表面散射部分（图中蓝色出射光）是漫射光（Diffuse Light），光线被散射到各个方向。双向反射分布函数BRDF就是用来模拟这种现象的，这也是本文关注的重点。\n如果光线在物质中的传播距离大于观察尺度，如下面的下图，就需要使用次表面散射算法来建模，@文刀秋二 写了一篇很好的关于次表面散射的文章。\n\n光照模型为了模拟非光学平面的散射，人们建立了各种模型，大致可以分为以下几类：\n1.测量模型MERL等实验室使用仪器测量了上百种真实材质表面在不同光照角度和观察角度下的反射数据，并记录在MERL BRDF Database等数据库中。这些数据由于采集自真实材质，所以使用它渲染出来的结果很真实，但缺点是没有可供调整效果的参数，无法基于这些数据修改成想要的效果，另外部分极端角度由于仪器限制，无法获取到数据，而且采样点密集，数据量非常庞大，所以并不适合游戏等实时领域，一般可用在电影等离线渲染领域，也可以用来做图形学研究，衡量其他模型的真实程度。\n2. 经验模型经验模型并不是基于物理原理，而是提出经验公式，通过调整参数来模拟光照。\n1975年Phong提出Phong反射模型（Phong Reflection Model） ：\nI_{Phong} = k_a I_a + k_d (n\\cdot l) I_d + k_s (r \\cdot v)^{\\alpha} I_s\n其中下标表示环境光（Ambient Light），下标表示漫射光（Diffuse Light），下标表示高光（Specular Light），表示反射系数或者材质颜色，表示光的颜色或者亮度，可以模拟表面的粗糙程度，值越小越粗糙，越大越光滑。\n反射向量根据光线入射向量相对法线做反射得到：\n\nPhong模型中，漫射光和高光分别会根据入射方向、反射方向和观察方向的变化而变化，还可以通过参数来调节表面粗糙程度，从而控制高光区域大小和锐利程度，而且运算简单，适合当时的计算机处理能力。\n1977年Blinn对Phong模型做出修改，这就是后来广泛使用的Blinn-Phong反射模型：\nI_{Blinn - Phong} = K_a I_a + k_d (n \\cdot l )I_d + k_s (n \\cdot h)^{\\alpha} I_s\n其中半角（Half-Angle）向量是光线入射向量和观察向量的中间向量： \n\nBlinn-Phong相比Phong，在观察方向趋向平行于表面时，高光形状会拉长，更接近真实情况。\nBlinn-Phong模型运算简单，适合早期硬件实现，在显卡只支持固定管线（Fixed Pipeline）的年代，Blinn-Phong模型是设计在显卡硬件中的，OpenGL/Direct3D固定管线的光照模型就是Blinn-Phong模型。但是Blinn-Phong模型毕竟只是一个经验模型，表现力有限，看起来有较重的塑料感。要想模拟各种不同材质的质感，得从光照的物理模型入手。\n3.基于物理的分析模型1967年Torrance-Sparrow在Theory for Off-Specular Reflection From Roughened Surfaces中使用辐射度学和微表面理论推导出粗糙表面的高光反射模型，1981年Cook-Torrance在A Reflectance Model for Computer Graphics中把这个模型引入到计算机图形学领域，现在无论是CG电影，还是3D游戏，基于物理着色都是使用的这个模型。我们将在下文中详细分析它的推导过程。\n辐射度学基本量图形学模拟可见光与各种材质的交互，这个过程涉及到能量的传输。辐射度学（Radiometry）是度量电磁辐射能量传输的学科，也是基于物理着色模型的基础。\n我们看看常用的辐射度学的基本量。\n1.能量能量（Energy），用符号表示，单位焦耳（）,每个光子都具有一定量的能量，和频率相关，频率越高，能量也越高。\n2.功率功率（Power），单位瓦特（Watts），或者焦耳/秒（）。辐射度学中，辐射功率也被称为辐射通量（Radiant Flux）或者通量（Flux），指单位时间内通过表面或者空间区域的能量的总量，用符号表示，定义。\n3.辐照度和幅出度辐照度（Irradiance），指单位时间内到达单位面积的辐射能量，或到达单位面积的辐射通量，也就是通量对于面积的密度。用符号表示，单位。定义为。\n辐出度（Radiant Existance），也称为辐射出射度、辐射度（Radiosity），用符号M表示。辐出度与辐照度类似，唯一的区别在辐出度衡量的是离开表面的通量密度，辐照度衡量的是到达表面的通量密度。辐照度和辐出度都可以称为辐射通量密度（Radiant Flux Density）。\n处理通量密度时，我们需要注意表面朝向和光线方向的角度。如下图所示，当光线垂直表面照射时，照射到表面上时的间距为；而当光线倾斜照射表面时（光照向量和表面法线的夹角为，间距为，光线间距相对垂直照射时变大了，也就是说倾斜照射时通量密度降低了。光照角度影响通量密度在我们日常生活中有很多实际例子，地球的季节变化就是因为光照角度变化，导致通量密度发生了变化。\n\n假定不垂直于光线传输方向的表面面积为，将它投影到垂直于光线方向得到一个虚拟表面，这个虚拟表面的面积为，通过这两个面积的通量是相同的，均为，则表面接收到的辐照度，虚拟表面上的辐照度，于是。\n点光源向四周辐射能量，假想以点光源为中心不同半径的球包围着点光源，穿过这些球的辐射通量是相同的，均为，而球的表面积为 ，可得通量密度，也就是说通量密度与距离的平方成反比，离光源越远，通量密度越低，这也是为什么光的衰减与距离的平方成正比。\n\n4.辐射强度​        讲辐射强度前，我们需要先知道立体角（Solid Angle）的概念，立体角可以看成是弧度的三维扩展。我们知道弧度是度量二维角度的量，等于角度在单位圆上对应的弧长，单位圆的周长是，所以整个圆对应的弧度也是 。立体角则是度量三维角度的量，用符号表示，单位为立体弧度（也叫球面度，Steradian，简写为sr），等于立体角在单位球上对应的区域的面积（实际上也就是在任意半径的球上的面积除以半径的平方），单位球的表面积是，所以整个球面的立体角也是。\n​        我们可以用一个向量和一个立体角来表示一束光线，向量表示这束光线的指向，立体角表示这束光线投射在单位球上的面积，也就是光束的粗细。如下图左边，向量l表示光源方向，微分立体角表示光束的粗细是无穷小。右边则表示面积光照到平面上的一点，立体角不再是无穷小。\n\n辐射强度（Radiant Intensity），指通过单位立体角的辐射通量。用符号表示，单位，定义为。\n之所以引入辐射强度，是因为有时候要度量通过一个点的通量的密度，但因为点的面积是0，无法使用辐照度，所以引入辐射强度。辐射强度不会随距离变化而变化，不像点光源的辐照度会随距离增大而衰减，这是因为立体角不会随距离变化而变化。\n5.辐射率我们常需要度量从一个微小面积表面出发，射向某个微小方向的通量（或者来自某个微小方向，照射到微小面积表面的通量），辐射率就是度量这种情况的量。\n辐射率（Radiance），指每单位面积每单位立体角的辐射通量密度。用符号表示，单位。定义为。其中是微分面积在垂直于光线方向的投影，如下图所示。\n\n辐射率实际上可以看成是我们眼睛看到（或相机拍到）的物体上一点的颜色。在基于物理着色时，计算表面一点的颜色就是计算它的辐射率。\n辐射率不会随距离变化而衰减，这和我们日常感受一致，在没有雾霾的干扰时，我们看到的物体表面上一点的颜色并不会随距离变化而变化。为什么辐照度会随距离增大而衰减，但是我们看到的颜色却不会衰减呢？这是因为随着距离变大，我们看到的物体上的一块区域到达视网膜的通量密度会变小，同时这块区域在视网膜表面上的立体角也会变小，正好抵消了通量密度的变化。\nBRDF我们看到一个表面，实际上是周围环境的光照射到表面上，然后表面将一部分光反射到我们眼睛里。双向反射分布函数BRDF（Bidirectional Reflectance Distribution Function）就是描述表面入射光和反射光关系的。\n对于一个方向的入射光，表面会将光反射到表面上半球的各个方向，不同方向反射的比例是不同的，我们用BRDF来表示指定方向的反射光和入射光的比例关系，BRDF定义为：\nf(l,v) = \\frac{dL_o(v)}{dE(l)}\n其中就是BRDF，是入射方向，是观察方向，也就是我们关心的反射方向。\n是表面反射到方向反射光的微分辐射率。表面反射到方向的反射光的辐射率为，来自于表面上半球所有方向的入射光线的贡献，而微分辐射率特指来自方向的入射光贡献的反射率。\n是表面上来自入射光方向的微分辐照度。表面接收到的辐照度为，来自上半球所有方向的入射光线的贡献，而微分辐照度特指来自于方向的入射光。\n\n表面对不同频率的光反射率可能不一样，因此BRDF和光的频率有关。在图形学中，将BRDF表示为RGB向量，三个分量各有自己的函数。\nBRDF需要处理表面上半球的各个方向，如下图使用球坐标系定义方向更加方便。球坐标系使用两个角度来确定一个方向：\n\n方向相对法线的角度，称为极角（Polar Angle）或天顶角（Zenith Angle）\n方向在平面上的投影相对于平面上一个坐标轴的角度，称为方位角（Azimuthal Angle）。\n\n所以BRDF也可以表示成。对于各向同性材质，当和同时绕法线旋转时，值保持不变，此时可以用和在平面投影的夹角来代替和 : 。\n\n至于为什么BRDF要定义成辐射率和辐照度的比值，而不是直接定义为辐射率和辐射率比值，有两种解释。\n第一种解释可以参看brdf为什么要定义为一个单位是sr-1的量？\n我们结合下面辐照度（A）和辐射率（B）测量仪的示意图来看看。辐照度测量仪（A）接受平面上半球的所有光线，可以测量一个较小面积来自于四面八方的所有光通量，光通量除以传感器面积就可以得到辐照度。辐射度测量仪（B）则有一个长筒控制光线只能从一个很小的立体角进入测量仪，光通量除以传感器面积和立体角就可以得到辐射率。\n测平面上一点在某一个方向的出射辐射率很简单，只需要用仪器（B）从该方向对准该点就可以了。而测平面一点入射的辐射率则没有那么简单，必须保证光源正好覆盖测量仪开口立体角，大了该点会接受到比测量值更多的光照，导致测量值比实际值小，小了则与仪器的设计立体角不一致，可在实际中是基本做不到光源大小正好覆盖测量仪开口立体角的。而测表面的辐照度则简单得多，只要保证光源很小，而且没有来自其他方向的光干扰，这时候测到的辐照度就是平面上来自光源方向的微分辐照度。\n\n第二种解释从数学的角度触发，对于现实世界中的非光学平面，一束光线射到表面上后，被表面反射到各个方向，其中一个出射方向的光通量只是整个反射光通量极小的一部分，当出射方向立体角趋于0时，\n，所以在实际计算中使用辐射率和辐射率比值是没有意义的。而如果分母改成表面上接收到的来自光源方向的微分辐照度，我们知道，由于给入射辐射率乘了一个趋于零的微分立体角，的值会小很多，比值是有意义的，而不是0.\n下面我们来看看怎么用BRDF计算表面辐照率：\n我们考虑来自方向的入射光辐射率，由辐射率和辐照度的定义：\nL_i(l) = \\frac{d\\Phi}{d\\omega_i dA^{\\perp}} = \\frac{d\\Phi}{d\\omega_i dA \\cos \\theta_i} = \\frac{dE(l)}{d\\omega_i \\cos \\theta_i}则照射到表面来自于方向的入射光贡献的微分辐照度：\n\n表面反射到方向的由来自于方向的入射光贡献的微分辐射率：\ndL_o(v) = f(l,v)\\bigotimes dE(l) = f(l,v)\\bigotimes L_i(l)d\\omega_i \\cos \\theta_i\n符号表示按向量的分量相乘，因为和都包含RGB三个分量。\n\n要计算表面反射到方向的来自上半球所有方向入射光线贡献的辐射率，可以将上式对半球所有方向的光线积分：\nL_o(v) = \\int_{\\Omega}f(l,v)\\bigotimes L_i(l)\\cos \\theta_i d\\omega_i上式称为反射方程（Reflectance Equation），用来计算表面反射辐射率。\n对于点光源、方向光等理想化的精准光源（Punctual Light），计算过程可以大大简化。我们考察单个精准光源照射表面，此时表面上的一点只会被来自一个方向的一条光线照射到（而面积光源照射表面时，表面上一点会被来自多个方向的多条光线照射到），则辐射率：\nL_o(v) = f(l,v)\\bigotimes E_L\\cos \\theta_i对于多个精准光源，只需要简单累加就可以了：\nL_o(v) = \\sum_{k=1}^{n}f(l_k,v)\\bigotimes E_{L_k} \\cos \\theta_{i_k}这里使用光源的辐照度，对于阳光等全局方向光，可以认为整个场景的辐照度是一个常数，对于点光源，辐照度随距离的平方衰减，用公式就可以求出到达表面的辐照度，是光源的功率，比如100瓦的灯泡，是表面离光源的距离。\n回头看看反射方程，是对表面上半球所有方向的入射光线积分，这里面包含了来自精准光源的光线，也包括周围环境反射的光线。处理来自周围环境的光线可以大幅提高光照的真实程度，在实时图形学中，这部分光照可以用基于图像的光照（Image Based Lighting）来模拟。我们将在下篇文章讨论基于图像的光照。\n上面给出了BRDF的定义和使用BRDF计算表面反射辐射率的公式。但这个定义实际上是无法直接用于计算表面反射辐射率的，我们还要建立一个能模拟真实光照的模型，使得输入入射方向和出射方向，能输出表面反射微分辐射率和入射微分辐照度的比率。\n1967年Torrance-Sparrow在Theory for Off-Specular Reflection From Roughened Surfaces中使用辐射度学和微表面理论建立了模拟真实光照的BRDF模型，1981年Cook-Torrance在A Reflectance Model for Computer Graphics中把这个模型引入到计算机图形学领域，现在这个模型已经成为基于物理着色的标准，被称为Cook-Torrance模型。下面我们来看看微表面理论和Cook-Torrance模型的推导过程。\n微表面理论微表面理论（Microfacet Theory）认为我们看到的表面上的一点是由很多朝向各异且光学平的微小表面组成。当光线从方向照射到这点，而我们在方向观察时，由于光学平面只会将光线反射到关于法线对称的方向，而和已经确定，所以只有法线朝向正好是和的半角向量的微表面才会将光线发射到方向（如下图，从而被我们看见）。\n\n我们用法线分布函数（Normal Distribution Function，简写为NDF）来描述组成表面一点的所有微表面的法线分布概率，现在可以这样理解：向NDF输入一个朝向,NDF会返回朝向的微表面数占微表面总数的比例（虽然实际并不是这样，这点我们在讲推导过程的时候再讲），比如有1%的微表面朝向是，那么就有1%的微表面可能将光线反射到方向。\n但实际上并不是所有微表面都能收到接受到光线，如下面左边的图有一部分入射光线被遮挡住，这种现象称为Shadowing。也不是所有反射光线都能到达眼睛，下面中间的图，一部分反射光线被遮挡住了，这种现象称为Masking。光线在微表面之间还会互相反射，如下面右边的图，这可能也是一部分漫射光的来源，在建模高光时忽略掉这部分光线。\n\nShadowing和Masking用几何衰减因子（Geometrical Attenuation Factor）来建模，输入入射和出射光线方向，输出值表示光线未被遮蔽而能从反射到方向的比例。\n光学平面并不会将所有光线都反射掉，而是一部分被反射，一部分被折射，反射比例符合菲涅尔方程（Fresnel Equations）\nTorrance-Sparrow基于微表面理论，用上述三个函数建立了高光BRDF模型：\nf(l,v) = \\frac{F(l,h)G(l,v)D(h)}{4 \\cos \\theta_i \\cos \\theta_o} = \\frac{F(l,h)G(l,v)D(h)}{4(n\\cdot l)(n \\cdot v)}\n其中是宏观表面法线，是微观表面法线。\n\n这个模型后来由Cook-Torrance引入计算机图形学，也被称为Cook-Torrance模型。不过Cook-Torrance的论文里上式分母里的系数由4改成了，但现在大家公认应该用4，下面我们来看看这个公式的推导过程。\nCook-Torrance模型公式推导我们考察一束光照射到一组微表面上，入射光方向，观察方向，对反射到方向的反射光有贡献的微表面法线为半角向量，则这束光的微分通量：\n\\mathrm{d}\\Phi_h = L_i(\\omega_i)\\mathrm{d}\\omega_iA^{\\perp} (\\omega_h) = L_i(\\omega_i) \\mathrm{d}\\omega_i \\cos \\theta_h \\mathrm{d}A (\\omega_h)\n其中是法线为半角向量的微分表面面积，为在入射光线方向的投影。为入射光线和微表面法线的夹角。\n\nTorrance-Sparrow将微分微表面面积定义为\norrance-Sparrow将前两项解释为单位面积微表面中朝向为的微分面积。不过这里塞一个略诡异，我的理解乘以并没有明确的数学或者物理上的意义。要从一组微表面面积中得到的朝向为的微表面面积，只需将定义微中朝向为的比例，取值范围在就可以了。这里引入的实际用途我们稍后再讨论。\n由上两式可得：\n\\mathrm{d}\\Phi_h = L_i(\\omega_i)\\mathrm{d}\\omega_i \\cos \\theta_h D(\\omega_h)\\mathrm{d}\\omega_h\\mathrm{d}A设定微表面反射光线遵循菲涅尔定理，则反射通量\n\\mathrm{d}\\Phi_o = F_r(\\omega_o)\\mathrm{d}\\Phi_h","categories":["LED"],"tags":["BRDF"]},{"title":"望远镜对LED的曝光时间计算","url":"/2022/05/17/%E6%9C%9B%E8%BF%9C%E9%95%9C%E5%AF%B9LED%E7%9A%84%E6%9B%9D%E5%85%89%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97/","content":"计算望远镜对LED的曝光时间一个像元对应的幕布面积焦面比例尺\n主镜口径\n焦比\n焦距\n焦面比例尺\\alpha = 206265''/f = 206265''/7200mm = 28.6479 ''/mm\n\n\n一个像元对应的幕布面积\n平场幕布直径\n视场角\n焦平面直径\n像元大小\n像元面积\n\n一个像元对应的平场幕布面积\n计算平场幕布处的辐照度辐照度（Irradiance）E_e = \\frac{d\\Phi_e}{dA}幕布处的辐照度\nLED在$do = 200mm处的辐照度为E{e0} = 21.9 \\mu W/mm^2$\n顶环距离幕布的距离\n\n则LED在平场幕布处的辐照度为$E{es} = E{e0}\\cdot d_0^2/d_1^2 \\thickapprox 5.683\\times 10^{-8} W$\n辐亮度为辐射亮度，定义为某个辐射传播方向上单位面积面光源单位立体角内的辐射通量。例如，面积为的辐射面，在和表面法线成角的方向上的立体角内发出的幅通量为，则辐射亮度可以表示为，单位是瓦特每球面度平方米，符号是\n\n双向反射函数BRDF定义为\n\n\n其中就是BRDF，是入射方向，是观察方向，也就是我们关心的反射方向。\n\n\n平场幕布的BRDF约为0.3\n\n\n\n则光经幕布反射后的辐亮度为$Le = E{es} \\times 0.3$\n主镜对应的立体角，用主镜面积近似计算。\n\n\n则CCD一个像元所能接收的辐射通量为\n\\Phi_e = L_e \\cdot ss \\cdot \\Omega = 0.3 \\times E_{es} \\cdot ss \\cdot \\Omega \\thickapprox  1.7\\times 10^{-8} W一个光子所携带的能量\n普朗克常数\n波长625nm一个光子的能量\n\n计算望远镜对LED的曝光时间\n望远镜在r波段带宽内效率均值（考虑滤光片）为55.63%\nAndor在650nm的量子效率约为72.9%\n\nCCD一个像素对应面积每秒辐射的光子数为$np = \\frac{\\Phi_e}{E{photon}} \\cdot 55.63 \\% \\cdot 72.9\\% = 14692408 $\nAndor相机的满阱容量典型值为\n上述计算结果仅为一个LED灯的，计算结果量级差了三个量级\n相关单位转换\n毫瓦  瓦（）\n1mW = 10^{-3}W\n微瓦  瓦（）\n1\\mu W = 10^{-6}W\n微米  毫米 \n1\\mu m = 10^{-3} mm\n纳米  米 \n1nm = 10^{-9}m\n\n","categories":["LED"],"tags":["LED"]},{"title":"辐射度学","url":"/2022/05/17/%E8%BE%90%E5%B0%84%E5%BA%A6%E5%AD%A6/","content":"辐射度学光是一种电磁波，从本质上讲，光的传播就是电磁\n辐射度量的名称和定义辐射能以辐射形式发射、传输或接收的能量称为辐射能。辐射能通常用表示，单位为焦耳，符号是。\n\n辐射通量​        在单位时间内通过某一面积的辐射能量称为经过该面积的辐射通量，而光源在单位时间内辐射出去的总能量被称为光源的辐射通量。辐射通量简称为辐通量，通常用表示，单位为瓦特，符号是。幅通量是描述光源发射特性的一个十分重要的辐射度量。根据定义，幅通量可以由辐射能随时间的变化率得到：\n\\Phi_e = \\frac{dQ_e}{dt}辐射强度​        辐射强度是指光源在某方向单位立体角内的辐射通量。辐射强度通常用表示，单位是瓦特每球面度，符号是。考虑一个能够向周围辐射能量的光源，如果其在某方向立体角内所发射的辐射通量为，则该光源在该方向的辐射强度可以用下式表示：\nI_e = \\frac{d\\Phi_e}{d\\Omega}​        大多数光源向空间各个方向发出的辐射通量往往是不均匀的，而辐射强度为描述光源在空间不同方向上辐射通量大小和分布提供了可能\n辐射亮度​        辐射亮度是用来表征有限尺寸辐射源的幅通量空间分布情况的物理量。具体定义为某个辐射传播方向上单位面积面光源单位立体角内的幅通量。例如，面积为的辐射面，在和表面法线成角的方向上的立体角内发出的幅通量为，则辐射亮度可以表示为\nL_e = \\frac{d\\Phi_e}{\\cos\\theta d A d\\Omega}单位为瓦特每球面度平方米，符号是。\n​        辐射亮度在光辐射的计算和测量中都具有重要作用，点光源的辐射特性通常用辐射强度描述，而较大的面光源则用辐射亮度描述其入射特性/例如，描述螺旋灯丝白炽灯时，常把它作为一个整体（即一个点光源），使用辐射强度描述其在给定观测方向上的辐射特性；而在描述天空辐射特性时，则用辐射亮度描述天空各部分辐射分布。\n辐射出射度​        光源的辐射出射度定义为离开光源表面单位面元的辐射通量。如果光源的某发光微面向所有方向（指该面元所对应的半球空间）所发射的辐射通量为，则该微面的辐射出射度可表示如下：\nM_e = \\frac{d\\Phi_e}{dA}单位为瓦特每平方米，符号是。需要注意的是面元所对应的立体角是辐射的整个半球空间。例如，太阳表面的辐射出射度指太阳表面单位表面积向外部空间发射的辐射通量。\n辐射照度​        物体的辐射照度定义为物体每单位面积所接收到的辐射通量，通常用符号表示，单位为瓦特每平方米，符号是。根据定义，辐射照度可以表示为：\nE_e = \\frac{d\\Phi_e}{dA}​        考虑一点光源，均匀向四周辐射能量。如果其辐射通量为，则其辐射强度为。考察与该点光源距离为的表面，该表面中心位置单位面积对点光源所张的立体角是，因此该表面的辐射照度可以表示为\nE_e = \\frac{I_e}{L^2} = \\frac{\\Phi_e}{4\\pi L^2}该公式符合逆平方定律，可描述为被照明表面的辐照度反比于辐照面到光源距离的平方。\n​        现将基本的辐射度量的名称、定义方程和单位总结如下表。\n\n\n\n\n名称\n符号\n定义方程\n单位名称\n单位符号\n\n\n\n\n辐射能\n\n\n焦耳\n\n\n\n辐射通量\n\n\n瓦特\n\n\n\n辐射强度\n\n\n瓦特每球面度\n\n\n\n辐射亮度\n\n\n瓦特每球面度平方米\n\n\n\n辐射出射度\n\n\n瓦特每平方米\n\n\n\n辐射照度\n\n\n瓦特每平方米\n\n\n\n\n\n郎伯辐射体​        大部分扩展辐射源都近似符合郎伯强度定律，即其辐射强度与空间方向的关系按如下简单规律变化：\nI_{\\theta} = I_N \\cos \\theta其中$IN为面源法线方向的辐射强度，I{\\theta}为和法线成任意角度\\theta方向的辐射强度。辐射强度I_{\\theta}端点的轨迹是一个与辐射面相切的球面，球心在法线上，球的直径为I_N$，如下图所示。符合这种规律的辐射体称为余弦辐射体或郎伯辐射体。\n","categories":["辐射度学"],"tags":["辐射度学"]},{"title":"辐射度量之间的转换","url":"/2022/05/17/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/","content":"辐射照度、辐射强度、光照度、发光强度（差异以及如何相互转换）\n这张图就可以解释为什么我们分不清辐照度和亮度之类的概念了。\n\n\n\n那么我们平时会如何用这些关系呢？\n例如：我们知道一个光源，而且知道光源发光强度，同时我们需要求空间一处面元接受的光照度\n\n","categories":["辐射度学"],"tags":["辐射照度"]},{"title":"辐射度学和光度学度量","url":"/2022/05/17/%E8%BE%90%E5%B0%84%E5%BA%A6%E5%AD%A6%E5%92%8C%E5%85%89%E5%BA%A6%E5%AD%A6%E5%BA%A6%E9%87%8F/","content":"辐射度学和光度学度量和辐射度学相比，光度学的研究对象只限于可见光范围内，并且要以人眼的视觉特性为基础。辐射度学中的所有概念，如光通量、光照强度等，都和视觉函数有关。光度量和辐射度量的定义是一一对应，下标列出了基本的辐射度量和光度量的名称、符号、方程和单位名称。有时为了避免混淆，在辐射度量符号上加上下标，在光度学符号上加上下标，如辐射度量、、等，光度量、、等。\n\n\n\n\n\n辐射度量\n光度量\n符号\n方程\n辐射度量单位名称和符号\n光度量单位名称和符号\n\n\n\n\n辐射量\n光量\n\n\n焦，\n流秒，\n\n\n辐射通量\n光通量\n\n\n瓦 (焦每秒), \n流，\n\n\n辐射强度\n发光强度\n\n\n瓦每球面度，\n坎，\n\n\n辐射亮度\n光亮度\n\n\n瓦每球面度平方米，\n坎每平方米，\n\n\n辐射出射度\n光出射度\n\n\n瓦每平方米，\n流每平方，\n\n\n辐射入射度\n光照度\n\n\n瓦每平方米，\n勒（流每平方米），\n\n\n\n\n","categories":["辐射度学"],"tags":["辐射度学"]},{"title":"立体角","url":"/2022/05/17/%E7%AB%8B%E4%BD%93%E8%A7%92/","content":"立体角给定一个正球体，它的半径为。然后给定一个正圆锥体，正圆锥体的顶点和球心重合，到圆锥底面圆边上任意一点的连线，即正圆锥体斜高，它的值也为。由正圆锥体的底面圆所截取的那一部分球面的面积和球体半径的平方的比称为立体角（solid angle），其国际单位是球面度（steradian）。下图展示了一个立体角的截面剖视示意图。\n\n\n若以表示立体角，则立体角的微分形式定义如下式所示。\nd\\Omega = \\frac{dA}{R^2}式中，为圆锥底面截取的球面的微元。\n若在球面坐标系下对立体角进行定义，如下图所示，面积微元的公式可以写为\n\n那么由，整个球面的立体角可写为关于和的二重积分形式：\n\\Omega = \\int{\\frac{dA}{R^2}} = \\int \\int d\\theta d\\varphi \\sin\\varphi = \\int^{2\\pi}_0 d\\varphi \\int^{\\pi}_0 \\sin \\theta d \\theta = 4\\pi","categories":["辐射度学"],"tags":["立体角"]},{"title":"1.2 算法分析","url":"/2023/07/21/1.2%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/","content":"算法分析\n第一次尝试的算法核心部分\n\nfor a in range(0, 1001):    for b in range(0, 1001):        for c in range(0, 1001):            if a**2 + b**2 == c**2 and a+b+c == 1000:                print(\"a, b, c: %d, %d, %d\" % (a, b, c))\n时间复杂度： $T(n) = O(nnn) = O(n_3)$\n\n\n第二次尝试的算法核心部分\n\nfor a in range(0, 1001):    for b in range(0, 1001-a):        c = 1000 - a - b        if a**2 + b**2 == c**2:            print(\"a, b, c: %d, %d, %d\" % (a, b, c))\n时间复杂度：$T(n) = O(nn(1+1)) = O(nn) = o(n^2)$\n\n由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。\n\n常见时间复杂度\n\n\n\n执行次数函数举例\n阶\n非正式术语\n\n\n\n\n12\nO(1)\n常数阶\n\n\n2n+3\nO(n)\n线性阶\n\n\n3n2+2n+1\nO(n2)\n平方阶\n\n\n5log2n+20\nO(logn)\n对数阶\n\n\n2n+3nlog2n+19\nO(nlogn)\nnlogn阶\n\n\n6n3+2n2+3n+4\nO(n3)\n立方阶\n\n\n2n\nO(2n)\n指数阶\n\n\n\n\n常见时间复杂度之间的关系\n所消耗的时间从小到大\n\nlist内置操作的时间复杂度\ndict内置操作的时间复杂度\n","categories":["Data Structure & Algorithm"],"tags":["Python","Data Structure"]},{"title":"Markdown-Cheat-Sheet","url":"/2022/05/19/Markdown-Cheat-Sheet/","content":"Markdown Cheat Sheet数学相关LaTeX表达前言后面介绍的内容是排版的数学符号的内容，不止一次有人强调中文版的Wikipedia并不是英文版内容的翻译，并不是。可以对比下参考部分的两个页面，我觉得中文页面做的不错，这两个页面里面关于垂直，貌似有那么点不同。\n\n表 1: 数学模式重音符\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\hat{a}\n\n\\check{a}\n\n\\tilde{a}\n\n\\acute{a}\n\n\n \n\\grave{a}\n \n\\dot{a}\n \n\\bar{a}\n\n\\ddot{a}\n\n\n \n\\vec{a}\n \n\\widehat{A}\n\n\\widetilde{A}\n\n\\breve{a}\n\n\n\n\n\n\\hat{A}\n\n\\tilde{A}\n\n\n\n\n\n表2: 小写希腊字母\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\alpha\n\n\\theta\n\n\\upsilon\n\no\n\n\n\n\\beta\n\n\\vartheta\n\n\\pi\n\n\\phi\n\n\n\n\\gamma\n\n\\iota\n\n\\varpi\n\n\\varphi\n\n\n\n\\delta\n\n\\kappa\n\n\\rho\n\n\\chi\n\n\n\n\\epsilon\n\n\\lambda\n\n\\varrho\n\n\\psi\n\n\n\n\\varepsilon\n\n\\mu\n\n\\sigma\n\n\\omega\n\n\n\n\\zeta\n\n\\nu\n\n\\varsigma\n\n\\nabla\n\n\n\n\\eta\n\n\\xi\n\n\\tau\n\n\n\n\n\n表 3: 大写希腊字母\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\Gamma\n\n\\Lambda\n\n\\Sigma\\mit\\Sigma\n\n\\Psi\n\n\n\n\\Delta\n\n\\Xi\n\n\\Upsilon\n\n\\Omega\\mit\\Omega\n\n\n\n\\Theta\n\n\\Pi\n\n\\Phi\n\n\n\n\n\n表 4: 数学字母\n\n\n\n示例\n代码\n\n\n\n\n\n\\mathbf {ABCdefxyzXYZ123}\n\n\n\n\\mathrm {ABCdefxyzXYZ123}\n\n\n\n\\mathit {ABCdefxyzXYZ123}\n\n\n\n\\mathcal {ABCdefxyzXYZ123}\n\n\n𝒹ℯ𝒻𝓍𝓎𝓏\n\\mathscr {ABCdefxyzXYZ123}\n\n\n\n\\mathfrak {ABCdefxyzXYZ123}\n\n\n𝕕𝕖𝕗𝕩𝕪𝕫𝟙𝟚𝟛\n\\mathbb {ABCdefxyzXYZ123}\n\n\n\n\\boldsymbol{ABCdefxyzXYZ123}\n\n\n\n\n表 5: 运算符与函数\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\sum\n\n\\prod\n\nx\\cdot{y}\n\n\n\n\\bigcup\n\n\\bigoplus\n\nx\\times {y}\n\n\n\n\\bigvee\n\n\\bigcap\n$\\left\\\nw\\right\\\n$\n**\\left\\\n\n\n\n\\bigwedge\n\n\\biguplus\n\n\\iiint\n\n\n\n\\bigotimes\n\n\\oint\n\n\\iint\n\n\n\n\\int x\\,{\\rm d}x\n\n\\bigsqcup\n\n\\lgroup \\rgroup\n\n\n\n\\coprod\n\n\\bigodot\n\n\\partial\n\n\n\n\\det\n\n\\max\n\n\\min\n\n\n\n\\log\n\n\n\n\n\n\n\n表 6: 常用箭头\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\leftarrow\n\n\\rightarrow\n\n\\leftrightarrow\n\n\n\n\\longleftarrow\n\n\\longrightarrow\n\n\\longleftrightarrow\n\n\n\n\\Leftarrow\n\n\\Rightarrow\n\n\\Leftrightarrow\n\n\n\n\\Longleftarrow\n\n\\Longrightarrow\n\n\\Longleftrightarrow\n\n\n\n\\uparrow\n\n\\downarrow\n\n\\updownarrow\n\n\n\n\n表 7: 其他常用符号\n\n\n\n示例\n代码\n示例\n代码\n示例\n代码\n\n\n\n\n\n\\therefore\n\n\\because\n\n\\min \\limits_{f \\in {H}}\n\n\n\n\\leqslant\n\n\\geqslant\n\n\\equiv\n\n\n\n\\thickapprox\n\n\\thicksim \\sim\n\n\\left(\\frac{A}{B}\\right)\n\n\n\n\\neq\n\n\\in\n\n\\hat{=}\n\n\n\n\\pm\n\n\\sqrt{a}\n\n\\geq \\leq\n\n\n\n\\perp\n\n\\angle\n\n\\varpropto\n\n\n\n\\infty\n\ng^\\prime\n\n\\forall\n\n\n\n\\exist\n\n\\bot\n\n\\top\n\n\n\n\n注意\\bot和\\perp的区别，垂直是\\perp\n表8: 使用字体\n\n\n\n示例\n代码\n备注\n\n\n\n\n\n\\rm {ABCdefXYZ123}\n罗马体\n\n\n\n\\it{ABCdefXYZ123}\n意大利体\n\n\n\n\\bf{ABCdefXYZ123}\n正粗体，黑体\n\n\n\n\\cal {ABCdefXYZ123}\n花体\n\n\n\n\\sf{ABCdefXYZ123}\n等线体\n\n\n\n\\mit{ABCdefXYZ123}\n数字斜体\n\n\n\n\\tt{ABCdefXYZ123}\n打印机字体\n\n\n\n\n表9: 分段函数与公式对齐分段函数示例\n\nf(x,y) = \\begin{cases}\n1 & x与y满足某一事实\\\\\n0 & 否则\n\\end{cases}# 代码f(x,y) = \\begin{cases}1 &amp; x与y满足某一事实\\\\0 &amp; 否则\\end{cases}\n\n\\begin{aligned}\nL(w)&=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\&=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\n\\end{aligned}对齐控制# 代码# 通过\\begin{aligned}\\end{aligned}控制对齐, 使用&amp;表示对齐点.\\begin{aligned}L(w)&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\\end{aligned}\n另外注意到前面的分段函数自动变好了，但是上面多行对齐的公式没有自动编号，如果需要自动编号，外面嵌入equation\n\n\\begin{equation}\n\\begin{aligned}\nL(w)&=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\n\\end{aligned}\n\\end{equation}代码如下\n\\begin{equation}\\begin{aligned}L(w)&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\\end{aligned}\\end{equation}\n公式编号关于编号也可以通过行间公式做如下表达\n\n\\begin{align}\nL(w)&=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\nonumber\\\\\n&=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\n\\end{align}代码如下\n\\begin{align}L(w)&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))]\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i\\log{\\frac{\\pi(x_i)}{1-\\pi(x_i)}}+\\log(1-\\pi(x_i))]\\nonumber\\\\&amp;=\\sum\\limits^{N}_{i=1}[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot{x_i})]\\end{align}\n以上代码有两点需要注意体会：\n\nalign\n\\nonumber的使用\n\n表X: 矩阵普通矩阵\n\\begin{aligned}\nM_1(x)=\n\\begin{bmatrix}\n&a_{01}&a_{02}\\\\\n&0&0\n\\end{bmatrix}\n&,M_2(x)=\n\\begin{bmatrix}\n&b_{11}&b_{12}\\\\\n&b_{21}&b_{22}\n\\end{bmatrix}\n\\\\\nM_3(x)=\n\\begin{bmatrix}\n&c_{11}&c_{12}\\\\\n&c_{21}&c_{22}\n\\end{bmatrix}\n&,M_4(x)=\n\\begin{bmatrix}\n&1&0\\\\\n&1&0\n\\end{bmatrix}\n\\end{aligned}\\begin{aligned}M_1(x)=\\begin{bmatrix}&amp;a_{01}&amp;a_{02}\\\\&amp;0&amp;0\\end{bmatrix}&amp;,M_2(x)=\\begin{bmatrix}&amp;b_{11}&amp;b_{12}\\\\&amp;b_{21}&amp;b_{22}\\end{bmatrix}\\\\M_3(x)=\\begin{bmatrix}&amp;c_{11}&amp;c_{12}\\\\&amp;c_{21}&amp;c_{22}\\end{bmatrix}&amp;,M_4(x)=\\begin{bmatrix}&amp;1&amp;0\\\\&amp;1&amp;0\\end{bmatrix}\\end{aligned}\n带省略符号的Matrix\nX^\\mathrm T=\n\\left[\n\\begin{matrix}\n x_{11} & \\cdots & x_{1N}       \\\\\n \\vdots & \\ddots & \\vdots         \\\\\n x_{M1} & \\cdots & x_{MN}       \\\\\n\\end{matrix}\n\\right]% 这里稍微注意下转置符号， 《统计学习方法》中的转置用的是正体的T% 可以参考 https://zhuanlan.zhihu.com/p/27490955 中关于转置写法的讨论。X^\\mathrm T=\\left[\\begin{matrix} x_{11} &amp; \\cdots &amp; x_{1N}       \\\\ \\vdots &amp; \\ddots &amp; \\vdots \t\t\\\\ x_{M1} &amp; \\cdots &amp; x_{MN}       \\\\\\end{matrix}\\right]\n向量\n\\left[\n\\begin{array}\n\\\\2\n\\\\3\n\\end{array}\n\\right]\\left[\\begin{array}\\\\2\\\\3\\end{array}\\right]\n\n\\overbrace{abcde}\\underbrace{fghij}_{comment}\\overline{klmn}\\underline{opqr}\\overleftarrow{stuv}\\overrightarrow{wxyz}\\overbrace{abcde}\\underbrace{fghij}_{comment}\\overline{klmn}\\underline{opqr}\\overleftarrow{stuv}\\overrightarrow{wxyz}\nEmoji表XI: Emoji\n\n\n\n:smirk: smirk\n:smile:smile\n:laughing:laughing\n:blush:blush\n:smiley:smiley\n:heart_eyes:heart_eyes\n\n\n\n\n😘kissing_heart\n:wink:wink\n:kissing:kissing\n:confused:confused\n:sweat:sweat\n:joy:joy\n\n\n:sob:sob\n:cry:cry\n:angry:angry\n:yum:yum\n:mask:mask\n:sunglasses:sunglasses\n\n\n:heartpulse:heartpulse\n:alien:alien\n:cupid:cupid\n:+1:+1\n:cn:cn\n:shit:shit\n\n\n\n\nRefs\nMarkdown 数学符号速查\nCmd Markdown公式指导手册\nEquals_Sign\nEmoji\nShort Math Guide for LaTeX\nList of Mathematical Symbols\n数学公式\nMatplotlib Math Text\n\n","categories":["Markdown"],"tags":["Markdown"]},{"title":"1.1 算法","url":"/2023/07/21/1.1%E7%AE%97%E6%B3%95/","content":"算法的概念算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。\n算法是独立存在的一种解决问题的方法和思想。\n对于算法而言，实现的语言并不重要，重要的是思想。\n算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等），我们现在是在用Python语言进行描述实现。\n\n算法的基本要素\n对数据对象的运算和操作：算术运算、逻辑运算、关系运算、数据传输\n算法的控制结构\n算法中各操作之间的执行顺序\n描述算法的工具：传统流程图、N-S结构化流程图、自然描述语言、伪代码描述、程序\n一个算法可以用顺序、选择（分支） 、循环（重复）三种基本结构组合而成\n\n\n算法的复杂度\n时间复杂度：执行算法所需要的计算工作量（基本运算次数），与所用计算工具无关，与采用的算法描述语言无关，也不取决于算法环境\n空间复杂度：执行算法所需要的内存空间（计算机所需存储空间）\n\n\n\n\n设计算法时需要考虑算法的的时间和空间复杂度，但两者相互独立，毫无关联\n\n\n算法分析方法：平均性态、最坏情况复杂性\n算法分析目的：降低算法复杂度，提高算法的执行效率，以求改进\n算法设计方法：列举法、归纳法、递推、递归、减半递推、回溯\n\n\n算法的执行效率与数据的存储结构有关\n算法强调动态的执行过程，不同于静态的计算公式\n\n算法的五大特性\n输入: 算法具有0个或多个输入\n输出: 算法至少有1个或多个输出\n有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成\n确定性：算法中的每一步都有确定的含义，不会出现二义性\n可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成\n\n算法的效率衡量执行时间反应算法效率对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。\n单靠时间值绝对可信吗？假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。\n单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！\n程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？\n时间复杂度与“大O记法”我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。\n对于算法的时间效率，我们可以用“大O记法”来表示。\n“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。\n时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)\n如何理解“大O记法”对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为和属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为n2级。\n最坏时间复杂度分析算法时，存在几种可能的考虑：\n\n算法完成工作最少需要多少基本操作，即最优时间复杂度\n算法完成工作最多需要多少基本操作，即最坏时间复杂度\n算法完成工作平均需要多少基本操作，即平均时间复杂度\n\n对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。\n对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。\n对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。\n因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。\n时间复杂度的几条基本计算规则\n基本操作，即只有常数项，认为其时间复杂度为O(1)\n顺序结构，时间复杂度按加法进行计算\n循环结构，时间复杂度按乘法进行计算\n分支结构，时间复杂度取最大值\n判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略\n在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度\n\n","categories":["Data Structure & Algorithm"],"tags":["Python","Data Structure"]},{"title":"1.3 数据结构","url":"/2023/07/21/1.3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"数据结构\n我们如何用Python中的类型来保存一个班的学生信息？ 如果想要快速的通过学生姓名获取其信息呢？\n\n实际上当我们在思考这个问题的时候，我们已经用到了数据结构。列表和字典都可以存储一个班的学生信息，但是想要在列表中获取一名同学的信息时，就要遍历这个列表，其时间复杂度为，而使用字典存储时，可将学生姓名作为字典的键，学生信息作为值，进而查询时不需要遍历便可快速获取到学生信息，其时间复杂度为。\n我们为了解决问题，需要将数据保存下来，然后根据数据的存储方式来设计算法实现进行处理，那么数据的存储方式不同就会导致需要不同的算法进行处理。我们希望算法解决问题的效率越快越好，于是我们就需要考虑数据究竟如何保存的问题，这就是数据结构。\n在上面的问题中我们可以选择Python中的列表或字典来存储学生信息。列表和字典就是Python内建帮我们封装好的两种数据结构。\n\n概念数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int, float, char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。\nPython给我们提供了很多现成的数据结构类型，这些系统自己定义好的，不需要我们自己去定义的数据结构叫做Python的内置数据结构，比如列表、元组、字典。而有些数据组织方式，Python系统里面没有直接定义，需要我们自己去定义实现这些数据的组织方式，这些数据组织方式称之为Python的扩展数据结构，比如栈，队列等。\n算法与数据结构的区别数据结构只是静态的描述了数据元素之间的关系。\n高效的程序需要在数据结构的基础上设计和选择算法。\n程序 = 数据结构 + 算法\n总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体\n抽象数据类型(Abstract Data Type)抽象数据类型(ADT)的含义是指一个数学模型以及定义在此数学模型上的一组操作。即把数据类型和数据类型上的运算捆在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。\n最常用的数据运算有五种：\n\n插入\n删除\n修改\n查找\n排序\n\n数据\n数据：需要处理的数据元素的集合\n\n数据元素：数据的基本单位，即数据集合中的个体，也是结点\n\n\n有时一个数据元素可由若干数据项(Data Item)组成，数据项是数据的最小单位\n\n结构：集合中各数据元素之间存在的某种前后件关系\n\n数据结构：指带有结构的相互有关联的数据元素的集合\n\n\n数据结构的分类\n\n数据结构作为计算机的一门学科，主要研究三个方面：数据间固有逻辑结构关系、数据的存储结构关系、数据结构的运算\n\n\n逻辑结构：反映数据元素之间的前后件逻辑关系的数据结构（与所使用的计算机无关）\n\n线性结构（线性表、栈、队列）\n非线性结构（树、图、二叉链表）\n\n\n存储结构：即物理结构，数据的逻辑结构在计算机空间中的存放方式（不同的存储结构，数据处理的效率不同，与效率有关）\n\n顺序结构：主要用于线性的数据结构\n链式结构：每一个结点至少包含一个指针域，用指针的指向来体现数据元素之间在逻辑上的联系 ，优点是便于插入和删除操作\n索引结构：带有目录与内容\n\n\n没有根结点或没有叶子结点的数据结构一定是非线性结构。\n所有数据结构不用必须有根结点或终端结点。\n\n\n\n\n\n\n\n运算：插入、删除、查找、排序\n\n线性表\n线性表：由n(n≥0)个数据元素构成的有限序列，表中由且只有一个根结点和一个终端结点，除根元素外的其它元素有且只有一个前件，除终端元素外的其它元素有且只有一个后件（如：春→夏→秋→冬）\n线性表的顺序存储结构叫做顺序表（随机存取），线性表的链式存储结构叫做线性链表（顺序存取）\n\n顺序表\n线性表中所有元素所占的存储空间是连续的\n线性表中数据元素在存储空间中是按逻辑顺序依次存放的\n可以随机访问数据元素\n做插入、删除时需移动大量元素，因此线性表不便于插入和删除元素\n其存储空间连续，各个元素所占字节数相同，元素的存储顺序与逻辑顺序一致\n\n\n线性链表\n各数据结点的存储空间可以不连续\n各数据元素的存储顺序与逻辑顺序可以不一致，可任意\n所占存储空间大于顺序存储结构（每节点多出至少一个指针域）\n查找结点时要比顺序存储慢\n插入删除元素比顺序存储灵活\n\n\n线性链表的操作：在线性链表中进行插入与删除，不需要移动链表中的元素\n\n\n栈\n栈的入口和出口是同一个口，只能在栈顶进行插入和删除\n\n栈的修改原则是“先进后出”或“后进先出”\n\n栈的栈底指针bottom和栈顶指针top，从入栈到栈满再到退栈，栈低指针bottom不变，栈中元素随栈顶指针的变化而动态变化（指针存放的是地址而非数据）\n\n栈能临时保存数据，具有记忆功能\n\n栈支持子程序调用\n\n\n\n\n一个栈的初始状态为空。将元素abcde依次入栈，不可能的出栈顺序为（E）\nA.edcba    B.dcbae    C.badce    D.cbaed    E.eabcd\n用一个长度为50的数组(数组元素的下标从0到49)作为栈的存储空间，如果bottom=49，top=30(数组下标)，则栈中具有的元素个数为【20】（49-30+1=20）\n设栈的存储空间为S（1：60），初始状态为top=61。现经过一系列正常的入栈与退栈操作后，top=25，则栈中的元素个数为【36】（60-25+1=36）\n栈内元素个数计算：丨Top－Bottom丨＋1 （其中Bottom≥1），若T＝B＝0说明栈空\n链式栈较特殊，当中存放元素与地址，但其栈底指针可以改变但不能省略\n与顺序栈相比的优点：入栈操作时不会受栈存储空间的限制而发生溢出，不受空间大小的限制，不需要考虑栈满的问题\n\n队列\n队列中队头指针front指向对头元素的前一位置，队尾指针rear指向最末元素，从入队到出队\n队列的入口和出口非同一个口，只允许在队尾插入，而在队头删除\n队列的修改原则是“先进先出”或“后进后出”（先到先服务的作业调度）\n队列中元素随front和rear的变化而动态变化，并非固定\n\n循环队列\n将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用\n\n\n\n求队列中的元素个数s（由rear与front共同决定）\n\nrear＞front        s=rear-front . rear＜front        s=rear-front+总容量 . rear＝front        s=0或者s=容量(满)\n\n设循环队列的存储空间为Q（1:40），初始状态为front=rear=40。经过一系列正常的入队与退队操作后，front=rear=15，此后又正常地退出了一个元素，则循环队列中的元素个数为    【39】 （当头尾指针都是15之后还能退出元素，说明初始状态为满，故退出一个元素，即40-1=3）\n\n树\n树：指n(n＞0)个元素的有限集合，它有且仅有一个称为根的元素，其余元素是互不相交的子树\n\n\n\n概念术语：\n父结点（A是BCD的父）、子结点（BCD是A的子)\n根结点（A）、叶子结点（KLFMHNJ）\n结点的度：一个结点所拥有的后件的个数（A的度为3、B的度为2）\n树的度：具有结点中最大的度（上图为3）\n树的深度：整棵树的层数（上图为4）\n子树：在一棵树中以某个结点的一个子结点为根所构成的树（如B→EF→KL这一左半部分）\n\n\n\n二叉树\n二叉树是一个有限的结点集合，该集合或为空，或由一个根结点及其两棵互不相交的左右二叉子树所组成，二叉链表是树的二叉链表实现方式。\n\n\n\n二又树的特点\n非空二又树只有一个根结点\n每一个结点最多有两棵子树，且分别称为该结点的左子树与右子树\n\n\n特殊二叉树\n\n\n\n满二叉树：除最后一层外，每一层上的结点数均达到最大值。\n完全二叉树：除最后一层外，每一层上的结点数均达到最大值，在最后一层上只缺少右边的若干结点\n\n满二叉树是完全二叉树，完全二叉树不是满二叉树\n\n\n\n二叉树的性质：\n\n非空二叉树只有一个根结点，每个结点最多有两棵子树，分别称为左子树和右子树\n在二叉树的第k层上，最多有2^(k-1)个结点（指定第几层求结点）\n深度为m的二叉树最多有2^(m)-1个结点（指定层数求结点）\n度为0的结点称为叶子结点，度=0的结点总比度=2的结点多1个\n有n个结点的二叉树深度至少为[log(2)n]+1（指定结点求深度）\n\n\n二叉树的遍历：按照一定的顺序不重复不遗漏地访问二叉树中的结点\n\n\n前序遍历：访问根结点→前序遍历左子树→前序遍历右子树（ABDGECF）（根左右） 中序遍历：中序遍历左子树→访问根结点→中序遍历右子树（DGBEACF）（左根右） 后序遍历：后序遍历左子树→后序遍历右子树→访问根结点（GDEBFCA）（左右根）\n\n\n\n","categories":["Data Structure & Algorithm"],"tags":["Python","Data Structe"]},{"title":"2 顺序表","url":"/2023/07/21/2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8/","content":"顺序表在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。\n对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。\n\n这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。\n根据线性表的实际存储方式，分为两种实现模型：\n\n顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。\n链表，将元素存放在通过链接构造起来的一系列存储块中。\n\n顺序表的基本形式\n图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即：\nLoc(ei) = Loc(e0) + c*i\n故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。\n如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。\n图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。\n顺序表的结构与实现顺序表的结构\n一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。\n顺序表的两种基本实现方式\n图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。\n一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。\n图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。\n元素存储区替换一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。\n分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。\n元素存储区扩充采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。\n扩充的两种策略\n\n每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。\n特点：节省空间，但是扩充操作频繁，操作次数多。\n\n每次扩充容量加倍，如每次扩充增加一倍存储空间。\n特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。\n\n\n顺序表的操作增加元素如图所示，为顺序表增加新元素111的三种方式\n\na. 尾端加入元素，时间复杂度为O(1)\nb. 非保序的加入元素（不常见），时间复杂度为O(1)\nc. 保序的元素加入，时间复杂度为O(n)\n删除元素\na. 删除表尾元素，时间复杂度为O(1)\nb. 非保序的元素删除（不常见），时间复杂度为O(1)\nc. 保序的元素删除，时间复杂度为O(n)\nPython中的顺序表Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。\ntuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。\nlist的基本实现技术Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：\n\n基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；\n为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。\n\n允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。\n为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。\n\n\n在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。\n在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。\n","categories":["Data Structure & Algorithm"],"tags":["Python","Data Structure"]},{"title":"C++修饰符类型","url":"/2023/07/23/C++%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/","content":"C++ 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。\n修饰符是用于改变变量类型的行为的关键字，它更能满足各种情境的需求。\n\n下面列出了数据类型修饰符：\n\nsigned：表示变量可以存储负数。对于整型变量来说，signed 可以省略，因为整型变量默认为有符号类型。\nunsigned：表示变量不能存储负数。对于整型变量来说，unsigned 可以将变量范围扩大一倍。\nshort：表示变量的范围比 int 更小。short int 可以缩写为 short。\nlong：表示变量的范围比 int 更大。long int 可以缩写为 long。\nlong long：表示变量的范围比 long 更大。C++11 中新增的数据类型修饰符。\nfloat：表示单精度浮点数。\ndouble：表示双精度浮点数。\nbool：表示布尔类型，只有 true 和 false 两个值。\nchar：表示字符类型。\nwchar_t：表示宽字符类型，可以存储 Unicode 字符。\n\n修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。\n这些修饰符也可以组合使用，修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。\nC++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 long，int 是隐含的。\n例如，下面的两个语句都声明了无符号整型变量。\nsigned int num1 = -10; // 定义有符号整型变量 num1，初始值为 -10unsigned int num2 = 20; // 定义无符号整型变量 num2，初始值为 20short int num1 = 10; // 定义短整型变量 num1，初始值为 10long int num2 = 100000; // 定义长整型变量 num2，初始值为 100000long long int num1 = 10000000000; // 定义长长整型变量 num1，初始值为 10000000000float num1 = 3.14f; // 定义单精度浮点数变量 num1，初始值为 3.14double num2 = 2.71828; // 定义双精度浮点数变量 num2，初始值为 2.71828bool flag = true; // 定义布尔类型变量 flag，初始值为 truechar ch1 = 'a'; // 定义字符类型变量 ch1，初始值为 'a'wchar_t ch2 = L'你'; // 定义宽字符类型变量 ch2，初始值为 '你'\n为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：\n#include &lt;iostream&gt;using namespace std; /*  * 这个程序演示了有符号整数和无符号整数之间的差别*/int main(){   short int i;           // 有符号短整数   short unsigned int j;  // 无符号短整数    j = 50000;    i = j;   cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j;    return 0;}\n当上面的程序运行时，会输出下列结果：\n-15536 50000\n上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。\nC++ 中的类型限定符类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。\n\n\n\n\n限定符\n含义\n\n\n\n\nconst\nconst 定义常量，表示该变量的值不能被修改。。\n\n\nvolatile\n修饰符 volatile 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。\n\n\nrestrict\n由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。\n\n\nmutable\n表示类中的成员变量可以在 const 成员函数中被修改。\n\n\nstatic\n用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。\n\n\nregister\n用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。\n\n\n\n\nconst 实例const int NUM = 10; // 定义常量 NUM，其值不可修改const int* ptr = &amp;NUM; // 定义指向常量的指针，指针所指的值不可修改int const* ptr2 = &amp;NUM; // 和上面一行等价\nvolatile 实例volatile int num = 20; // 定义变量 num，其值可能会在未知的时间被改变\nmutable 实例class Example {public:    int get_value() const {        return value_; // const 关键字表示该成员函数不会修改对象中的数据成员    }    void set_value(int value) const {        value_ = value; // mutable 关键字允许在 const 成员函数中修改成员变量    }private:    mutable int value_;};\nstatic 实例void example_function() {    static int count = 0; // static 关键字使变量 count 存储在程序生命周期内都存在    count++;}\nregister 实例void example_function(register int num) {    // register 关键字建议编译器将变量 num 存储在寄存器中    // 以提高程序执行速度    // 但是实际上是否会存储在寄存器中由编译器决定}\n","categories":["C++"],"tags":["C++"]},{"title":"C++基本语法","url":"/2023/07/20/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"C++基本语法C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。\n\n对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。\n类 - 类可以定义为描述对象行为/状态的模板/蓝图。\n方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。\n即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。\n\n\nC++ 程序结构让我们看一段简单的代码，可以输出单词 Hello World。\n#include &lt;iostream&gt;using namespace std;// main() 是程序开始执行的地方int main(){    cout &lt;&lt; \"Hello World\"; // 输出 Hello World    return 0; } \n接下来我们讲解一下上面这段程序：\n\nC++ 定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了 头文件。\n行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。\n下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。\n下一行 int main() 是主函数，程序从这里开始执行。\n下一行 cout &lt;&lt; “Hello World”; 会在屏幕上显示消息 “Hello World”。\n下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。\n\n\n 是一个输入输出流相关的头文件。里面包含了一些对输入输出流操作的方法。\n\n编译 &amp; 执行 C++ 程序接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：\n\n打开一个文本编辑器，添加上述代码。\n保存文件为 hello.cpp。\n打开命令提示符，进入到保存文件所在的目录。\n键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。\n现在，键入 ‘ a.out’ 来运行程序。\n您可以看到屏幕上显示 ‘ Hello World ‘。\n\n$ g++ hello.cpp$ ./a.outHello World\n请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。\n您也可以使用 makefile 来编译 C/C++ 程序。\nC++ 中的分号 &amp; 块在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。\n例如，下面是三个不同的语句：\nx = y;y = y+1;add(x, y);\n块是一组使用大括号括起来的按逻辑连接的语句。例如：\n{    cout &lt;&lt; \"Hello World\"; // 输出 Hello World    return 0;} \nC++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：\nx = y;y = y+1;add(x, y);\n等同于\nx = y; y = y+1; add(x, y);\nC++ 标识符C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。\nC++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符。\n下面列出几个有效的标识符：\nmohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal\nC++ 关键字下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。\n\n\n\n\nasm\nelse\nnew\nthis\n\n\n\n\nauto\nenum\noperator\nthrow\n\n\nbool\nexplicit\nprivate\ntrue\n\n\nbreak\nexport\nprotected\ntry\n\n\ncase\nextern\npublic\ntypedef\n\n\ncatch\nfalse\nregister\ntypeid\n\n\nchar\nfloat\nreinterpret_cast\ntypename\n\n\nclass\nfor\nreturn\nunion\n\n\nconst\nfriend\nshort\nunsigned\n\n\nconst_cast\ngoto\nsigned\nusing\n\n\ncontinue\nif\nsizeof\nvirtual\n\n\ndefault\ninline\nstatic\nvoid\n\n\ndelete\nint\nstatic_cast\nvolatile\n\n\ndo\nlong\nstruct\nwchar_t\n\n\ndouble\nmutable\nswitch\nwhile\n\n\ndynamic_cast\nnamespace\ntemplate\n\n\n\n\n三字符组三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。\n三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。\n三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。\n下面列出了最常用的三字符序列：\n\n\n\n\n三字符组\n替换\n\n\n\n\n??=\n#\n\n\n??/\n\\\n\n\n??’\n^\n\n\n??(\n[\n\n\n??)\n]\n\n\n??!\n\\\n\n\n\n??&lt;\n{\n\n\n??&gt;\n}\n\n\n??-\n~\n\n\n\n\n所有的编译器都不支持三字符组，为避免造成混乱，不建议使用三字符组。\nC++ 中的空格只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。\n在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：\nint age;\n在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：\nfruit = apples + oranges;   // 获取水果的总数\nfruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。\nC++ 注释程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。\nC++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。\nC++ 注释以 / 开始，以 / 终止。例如：\n/* 这是注释 *//* C++ 注释也可以 * 跨行 */\n注释也能以 // 开始，直到行末为止。例如：\n#include &lt;iostream&gt;using namespace std; int main(){   cout &lt;&lt; \"Hello World!\"; // 输出 Hello World!    return 0;}\n尝试一下\n当上面的代码被编译时，编译器会忽略 // prints Hello World，最后会产生以下结果：\nHello World\n在 / 和 / 注释内部，// 字符没有特殊的含义。在 // 注释内，/ 和 / 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：\n/* 用于输出 Hello World 的注释cout &lt;&lt; \"Hello World\"; // 输出 Hello World  */ \n","categories":["C++"],"tags":["C++"]},{"title":"C++变量作用域","url":"/2023/07/23/C++%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"C++ 变量作用域一般来说有三个地方可以定义变量：\n\n在函数或一个代码块内部声明的变量，称为局部变量。\n在函数参数的定义中声明的变量，称为形式参数。\n在所有函数外部声明的变量，称为全局变量。\n\n\n作用域是程序的一个区域，变量的作用域可以分为以下几种：\n\n局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。\n全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。\n块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。\n类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。\n\n\n注意：如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。\n\n局部变量在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：\n#include &lt;iostream&gt;using namespace std; int main (){  // 局部变量声明  int a, b;  int c;   // 实际初始化  a = 10;  b = 20;  c = a + b;   cout &lt;&lt; c;   return 0;}\n全局变量在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n#include &lt;iostream&gt;using namespace std; // 全局变量声明int g; int main (){  // 局部变量声明  int a, b;   // 实际初始化  a = 10;  b = 20;  g = a + b;   cout &lt;&lt; g;   return 0;}\n在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：\n#include &lt;iostream&gt;using namespace std; // 全局变量声明int g = 20; int main (){  // 局部变量声明  int g = 10;   cout &lt;&lt; g;   return 0;}\n当上面的代码被编译和执行时，它会产生下列结果：\n10\n初始化局部变量和全局变量当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：\n\n\n\n\n数据类型\n初始化默认值\n\n\n\n\nint\n0\n\n\nchar\n‘\\0’\n\n\nfloat\n0\n\n\ndouble\n0\n\n\npointer\nNULL\n\n\n\n\n正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。\n块作用域指的是在代码块内部声明的变量：\n#include &lt;iostream&gt;int main() {    int a = 10;    {        int a = 20;  // 块作用域变量        std::cout &lt;&lt; \"块变量: \" &lt;&lt; a &lt;&lt; std::endl;    }    std::cout &lt;&lt; \"外部变量: \" &lt;&lt; a &lt;&lt; std::endl;    return 0;}\n以上实例中，内部的代码块中声明了一个名为 a 的变量，它与外部作用域中的变量 a 同名。内部作用域中的变量 a 将覆盖外部作用域中的变量 a，在内部作用域中访问 a 时输出的是20，而在外部作用域中访问 a 时输出的是 10。\n当上面的代码被编译和执行时，它会产生下列结果：\n块变量: 20外部变量: 10\n类作用域类作用域指的是在类内部声明的变量：\n#include &lt;iostream&gt;class MyClass {public:    static int class_var;  // 类作用域变量};int MyClass::class_var = 30;int main() {    std::cout &lt;&lt; \"类变量: \" &lt;&lt; MyClass::class_var &lt;&lt; std::endl;    return 0;}\n以上实例中，MyClass 类中声明了一个名为 class_var 的类作用域变量。可以使用类名和作用域解析运算符 :: 来访问这个变量。在 main() 函数中访问 class_var 时输出的是 30。\n类变量: 30\n","categories":["C++"],"tags":["C++"]},{"title":"C++变量类型","url":"/2023/07/21/C++%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/","content":"C++ 变量类型\n变量其实只不过是程序可操作的存储区的名称。在 C++ 中，有多种变量类型可用于存储不同种类的数据。\n\nC++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。\n\n变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。\n\n\n\n基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：\n\n\n\n\n类型\n描述\n\n\n\n\nbool\n布尔类型，存储值 true 或 false，占用 1 个字节。\n\n\nchar\n字符类型，用于存储 ASCII 字符，通常占用 1 个字节。\n\n\nint\n整数类型，通常用于存储普通整数，通常占用 4 个字节。\n\n\nfloat\n单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。\n\n\ndouble\n双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。\n\n\nvoid\n表示类型的缺失。\n\n\nwchar_t\n宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节。\n\n\n\n\nC++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。\n\n整数类型（Integer Types）：\nint：用于表示整数，通常占用4个字节。\nshort：用于表示短整数，通常占用2个字节。\nlong：用于表示长整数，通常占用4个字节。\nlong long：用于表示更长的整数，通常占用8个字节。\n\n\n浮点类型（Floating-Point Types）：\nfloat：用于表示单精度浮点数，通常占用4个字节。\ndouble：用于表示双精度浮点数，通常占用8个字节。\nlong double：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。\n\n\n字符类型（Character Types）：\nchar：用于表示字符，通常占用1个字节。\nwchar_t：用于表示宽字符，通常占用2或4个字节。\nchar16_t：用于表示16位Unicode字符，占用2个字节。\nchar32_t：用于表示32位Unicode字符，占用4个字节。\n\n\n布尔类型（Boolean Type）：\nbool：用于表示布尔值，只能取true或false。\n\n\n枚举类型（Enumeration Types）：\nenum：用于定义一组命名的整数常量。\n\n\n指针类型（Pointer Types）：\ntype*：用于表示指向类型为type的对象的指针。\n\n\n数组类型（Array Types）：\ntype[]或type[size]：用于表示具有相同类型的元素组成的数组。\n\n\n结构体类型（Structure Types）：\nstruct：用于定义包含多个不同类型成员的结构。\n\n\n类类型（Class Types）：\nclass：用于定义具有属性和方法的自定义类型。\n\n\n共用体类型（Union Types）：\nunion：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。\n\n\n\n下面我们将讲解如何定义、声明和使用各种类型的变量。\nC++ 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。\n\n变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：\ntype variable_list;\n在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：\nint    i, j, k;char   c, ch;float  f, salary;double d;\n行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。\n变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：\ntype variable_name = value;\n下面列举几个实例：\nextern int d = 3, f = 5;    // d 和 f 的声明 int d = 3, f = 5;           // 定义并初始化 d 和 fbyte z = 22;                // 定义并初始化 zchar x = 'x';               // 变量 x 的值为 'x'\n不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。\nC++ 中的变量声明变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。\n#include &lt;iostream&gt;using namespace std; // 变量声明extern int a, b;extern int c;extern float f;  int main (){  // 变量定义  int a, b;  int c;  float f;   // 实际初始化  a = 10;  b = 20;  c = a + b;   cout &lt;&lt; c &lt;&lt; endl ;   f = 70.0/3.0;  cout &lt;&lt; f &lt;&lt; endl ;   return 0;}\n变量在头部就已经被声明，但它们是在主函数内被定义和初始化的，当上面的代码被编译和执行时，它会产生下列结果：\n3023.3333\n同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：\n// 函数声明int func(); int main(){    // 函数调用    int i = func();} // 函数定义int func(){    return 0;}\nC++ 中的左值（Lvalues）和右值（Rvalues）C++ 中有两种类型的表达式：\n\n左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：\nint g = 20;\n但是下面这个就不是一个有效的语句，会生成编译时错误：\n10 = 20;\n","categories":["C++"],"tags":["C++"]},{"title":"C++常量","url":"/2023/07/23/C++%E5%B8%B8%E9%87%8F/","content":"C++ 常量常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。\n常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。\n常量就像是常规的变量，只不过常量的值在定义后不能进行修改。\n\n整数常量整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n下面列举几个整数常量的实例：\n212         // 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀\n以下是各种类型的整数常量的实例：\n85         // 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数\n浮点常量浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n下面列举几个浮点常量的实例：\n3.14159       // 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数\n布尔常量布尔常量共有两个，它们都是标准的 C++ 关键字：\n\ntrue 值代表真。\nfalse 值代表假。\n\n我们不应把 true 的值看成 1，把 false 的值看成 0。\n字符常量字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。\n字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。\n在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码：\n\n\n\n\n转义序列\n含义\n\n\n\n\n\\\n\\ 字符\n\n\n\\’\n‘ 字符\n\n\n\\”\n“ 字符\n\n\n\\?\n? 字符\n\n\n\\a\n警报铃声\n\n\n\\b\n退格键\n\n\n\\f\n换页符\n\n\n\\n\n换行符\n\n\n\\r\n回车\n\n\n\\t\n水平制表符\n\n\n\\v\n垂直制表符\n\n\n\\ooo\n一到三位的八进制数\n\n\n\\xhh . . .\n一个或多个数字的十六进制数\n\n\n\n\n下面的实例显示了一些转义序列字符：\n#include &lt;iostream&gt;using namespace std; int main(){   cout &lt;&lt; \"Hello\\tWorld\\n\\n\";   return 0;}\n当上面的代码被编译和执行时，它会产生下列结果：\nHello   World\n字符串常量字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。\n您可以使用 \\ 做分隔符，把一个很长的字符串常量进行分行。\n下面的实例显示了一些字符串常量：\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string greeting = \"hello, runoob\";    cout &lt;&lt; greeting;    cout &lt;&lt; \"\\n\";     // 换行符    string greeting2 = \"hello, \\                        runoob\";    cout &lt;&lt; greeting2;    return 0;}\nhello, runoobhello, runoob\n定义常量在 C++ 中，有两种简单的定义常量的方式：\n\n使用 #define 预处理器。\n使用 const 关键字。\n\n#define 预处理器下面是使用 #define 预处理器定义常量的形式：\n#define identifier value\n具体请看下面的实例：\n#include &lt;iostream&gt;using namespace std; #define LENGTH 10   #define WIDTH  5#define NEWLINE '\\n' int main(){    int area;        area = LENGTH * WIDTH;   cout &lt;&lt; area;   cout &lt;&lt; NEWLINE;   return 0;}\n当上面的代码被编译和执行时，它会产生下列结果：\n50\nconst 关键字您可以使用 const 前缀声明指定类型的常量，如下所示：\nconst type variable = value;\n具体请看下面的实例：\n#include &lt;iostream&gt;using namespace std; int main(){   const int  LENGTH = 10;   const int  WIDTH  = 5;   const char NEWLINE = '\\n';   int area;        area = LENGTH * WIDTH;   cout &lt;&lt; area;   cout &lt;&lt; NEWLINE;   return 0;}\n当上面的代码被编译和执行时，它会产生下列结果：\n50\n请注意，把常量定义为大写字母形式，是一个很好的编程实践。\n","categories":["C++"],"tags":["C++"]},{"title":"C++数据类型","url":"/2023/07/20/C++%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"C++ 数据类型使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。\n您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。\n\n基本的内置类型C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：\n\n\n\n\n类型\n关键字\n\n\n\n\n布尔型\nbool\n\n\n字符型\nchar\n\n\n整型\nint\n\n\n浮点型\nfloat\n\n\n双浮点型\ndouble\n\n\n无类型\nvoid\n\n\n宽字符型\nwchar_t\n\n\n\n\n一些基本类型可以使用一个或多个类型修饰符进行修饰：\n\nsigned\nunsigned\nshort\nlong\n\n下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。\n\n 注意：不同系统会有所差异。\n注意：默认情况下，int、short、long都是带符号的，即 signed。\n注意：long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。\n\n\n\n\n\n类型\n位\n范围\n\n\n\n\nchar\n1 个字节\n-128 到 127 或者 0 到 255\n\n\nunsigned char\n1 个字节\n0 到 255\n\n\nsigned char\n1 个字节\n-128 到 127\n\n\nint\n4 个字节\n-2147483648 到 2147483647\n\n\nunsigned int\n4 个字节\n0 到 4294967295\n\n\nsigned int\n4 个字节\n-2147483648 到 2147483647\n\n\nshort int\n2 个字节\n-32768 到 32767\n\n\nunsigned short int\n2 个字节\n0 到 65,535\n\n\nsigned short int\n2 个字节\n-32768 到 32767\n\n\nlong int\n8 个字节\n-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\n\n\nsigned long int\n8 个字节\n-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\n\n\nunsigned long int\n8 个字节\n0 到 18,446,744,073,709,551,615\n\n\nfloat\n4 个字节\n精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)\n\n\ndouble\n8 个字节\n双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308(~15 个数字)\n\n\nlong double\n16 个字节\n长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。\n\n\nwchar_t\n2 或 4 个字节\n1 个宽字符\n\n\n\n\n\n注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。\n以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：\n\n\n从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。\n下面实例会输出您电脑上各种数据类型的大小。\n#include &lt;iostream&gt;using namespace std;int main(){   cout &lt;&lt; \"Size of char : \" &lt;&lt; sizeof(char) &lt;&lt; endl;   cout &lt;&lt; \"Size of int : \" &lt;&lt; sizeof(int) &lt;&lt; endl;   cout &lt;&lt; \"Size of short int : \" &lt;&lt; sizeof(short int) &lt;&lt; endl;   cout &lt;&lt; \"Size of long int : \" &lt;&lt; sizeof(long int) &lt;&lt; endl;   cout &lt;&lt; \"Size of float : \" &lt;&lt; sizeof(float) &lt;&lt; endl;   cout &lt;&lt; \"Size of double : \" &lt;&lt; sizeof(double) &lt;&lt; endl;   cout &lt;&lt; \"Size of wchar_t : \" &lt;&lt; sizeof(wchar_t) &lt;&lt; endl;   return 0;}\n本实例使用了 endl，这将在每一行后插入一个换行符，&lt;&lt; 运算符用于向屏幕传多个值。我们也使用 sizeof() 函数来获取各种数据类型的大小。\n当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：\nSize of char : 1Size of int : 4Size of short int : 2Size of long int : 4Size of float : 4Size of double : 8Size of wchar_t : 4\ntypedef 声明您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：\ntypedef type newname; \n例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：\ntypedef int feet;\n现在，下面的声明是完全合法的，它创建了一个整型变量 distance：\nfeet distance;\n枚举类型枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n枚举类型声明一个可选的类型名称和一组标识符，用来作为该类型的值。其带有零个或多个标识符可以被用来作为该类型的值。每个枚举数是一个枚举类型的常数。\n创建枚举，需要使用关键字 enum。枚举类型的一般形式为：\nenum enum-name { list of names } var-list; \n在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。\n例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。\nenum color { red, green, blue } c;c = blue;\n默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。\nenum color { red, green=5, blue };\n在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。\n类型转换类型转换是将一个数据类型的值转换为另一种数据类型的值。\nC++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。\n静态转换（Static Cast）静态转换是将一种数据类型的值强制转换为另一种数据类型的值。\n静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。\n静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。\nint i = 10;float f = static_cast&lt;float&gt;(i); // 静态将int类型转换为float类型\n动态转换（Dynamic Cast）动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。\nclass Base {};class Derived : public Base {};Base* ptr_base = new Derived;Derived* ptr_derived = dynamic_cast&lt;Derived*&gt;(ptr_base); // 将基类指针转换为派生类指针\n常量转换（Const Cast）常量转换用于将 const 类型的对象转换为非 const 类型的对象。\n常量转换只能用于转换掉 const 属性，不能改变对象的类型。\nconst int i = 10;int&amp; r = const_cast&lt;int&amp;&gt;(i); // 常量转换，将const int转换为int\n重新解释转换（Reinterpret Cast）重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。\n重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。\nint i = 10;float f = reinterpret_cast&lt;float&amp;&gt;(i); // 重新解释将int类型转换为float类型\n","categories":["C++"],"tags":["C++"]},{"title":"C++存储类","url":"/2023/07/23/C++%E5%AD%98%E5%82%A8%E7%B1%BB/","content":"C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：\n\nauto\nregister\nstatic\nextern\nmutable\nthread_local (C++11)\n\n\n从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。\n\n\nauto 存储类自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\nC++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。\n根据初始化表达式自动推断被声明的变量的类型，如：\nauto f=3.14;      //doubleauto s(\"hello\");  //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\nregister 存储类register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。\n{   register int  miles;}\n寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。\nstatic 存储类static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\n在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。\n实例#include &lt;iostream&gt; // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main(){    while(count--)    {       func();    }    return 0;}// 函数定义void func( void ){    static int i = 5; // 局部静态变量    i++;    std::cout &lt;&lt; \"变量 i 为 \" &lt;&lt; i ;    std::cout &lt;&lt; \" , 变量 count 为 \" &lt;&lt; count &lt;&lt; std::endl;}\n当上面的代码被编译和执行时，它会产生下列结果：\n变量 i 为 6 , 变量 count 为 9变量 i 为 7 , 变量 count 为 8变量 i 为 8 , 变量 count 为 7变量 i 为 9 , 变量 count 为 6变量 i 为 10 , 变量 count 为 5变量 i 为 11 , 变量 count 为 4变量 i 为 12 , 变量 count 为 3变量 i 为 13 , 变量 count 为 2变量 i 为 14 , 变量 count 为 1变量 i 为 15 , 变量 count 为 0\nextern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n第一个文件：main.cpp\n#include &lt;iostream&gt; int count ;extern void write_extern(); int main(){   count = 5;   write_extern();}\n第二个文件：support.cpp\n#include &lt;iostream&gt; extern int count; void write_extern(void){   std::cout &lt;&lt; \"Count is \" &lt;&lt; count &lt;&lt; std::endl;}\n在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：\n$ g++ main.cpp support.cpp -o write\n这会产生 write 可执行程序，尝试执行 write，它会产生下列结果：\n$ ./writeCount is 5\nmutable 存储类mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。\nthread_local 存储类使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\nthread_local 说明符可以与 static 或 extern 合并。\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\n以下演示了可以被声明为 thread_local 的变量：\nthread_local int x;  // 命名空间下的全局变量class X{    static thread_local std::string s; // 类的static成员变量};static thread_local std::string X::s;  // X::s 是需要定义的 void foo(){    thread_local std::vector&lt;int&gt; v;  // 本地变量}\n","categories":["C++"],"tags":["C++"]},{"title":"C++简介","url":"/2023/07/20/C++%E7%AE%80%E4%BB%8B/","content":"C++简介C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持面向过程编程、面向对象编程和泛型编程。\nC++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。\n\nC++ 是由 Bjarne Stroustrup（C++之父） 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C（C with classes），后来在 1983 年更名为 C++。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n面向对象程序设计C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：\n\n封装\n抽象\n继承\n多态\n\n标准库标准的 C++ 由三个重要部分组成：\n\n核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。\nC++ 标准库，提供了大量的函数，用于操作文件、字符串等。\n标准模板库（STL），提供了大量的方法，用于操作数据结构等。\n\nANSI 标准ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。\n由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。\n学习 C++学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。\n学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。\nC++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。\n\nC++ 的使用基本上每个应用程序领域的程序员都有使用 C++。\nC++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。\nC++ 广泛用于教学和研究。\n任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。\n","categories":["C++"],"tags":["C++"]},{"title":"单向链表","url":"/2023/07/21/3.1%20%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/","content":"链表为什么需要链表顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行扩充时又需要进行数据的搬迁，所以使用起来并不是很灵活。\n链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。\n\n链表的定义链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。\n\n单向链表单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。\n\n表元素域elem用来存放具体的数据。\n链接域next用来存放下一个节点的位置（python中的标识）\n变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。\n\n节点实现class SingleNode(object):    \"\"\"单链表的结点\"\"\"    def __init__(self,item):        # _item存放数据元素        self.item = item        # _next是下一个节点的标识        self.next = None\n单链表的操作\nis_empty()链表是否为空\nlength() 链表长度\ntravel()遍历整个链表\nadd(item) 链表头部添加元素\nappend(item)链表尾部添加元素\ninsert(pos, item) 指定位置添加元素\nremove(item) 删除节点\nsearch(item) 查找节点是否存在\n\n单链表的实现class SingleLinkList(object):    \"\"\"单链表\"\"\"    def __init__(self):        self._head = None    def is_empty(self):        \"\"\"判断链表是否为空\"\"\"        return self._head == None    def length(self):        \"\"\"链表长度\"\"\"        # cur初始时指向头节点        cur = self._head        count = 0        # 尾节点指向None，当未到达尾部时        while cur != None:            count += 1            # 将cur后移一个节点            cur = cur.next        return count    def travel(self):        \"\"\"遍历链表\"\"\"        cur = self._head        while cur != None:            print cur.item,            cur = cur.next        print \"\"\n头部添加元素\ndef add(self, item):    \"\"\"头部添加元素\"\"\"    # 先创建一个保存item值的节点    node = SingleNode(item)    # 将新节点的链接域next指向头节点，即_head指向的位置    node.next = self._head    # 将链表的头_head指向新节点    self._head = node\n尾部添加元素def append(self, item):    \"\"\"尾部添加元素\"\"\"    node = SingleNode(item)    # 先判断链表是否为空，若是空链表，则将_head指向新节点    if self.is_empty():        self._head = node    # 若不为空，则找到尾部，将尾节点的next指向新节点    else:        cur = self._head        while cur.next != None:            cur = cur.next        cur.next = node\n指定位置添加元素\ndef insert(self, pos, item):    \"\"\"指定位置添加元素\"\"\"    # 若指定位置pos为第一个元素之前，则执行头部插入    if pos &lt;= 0:        self.add(item)    # 若指定位置超过链表尾部，则执行尾部插入    elif pos &gt; (self.length()-1):        self.append(item)    # 找到指定位置    else:        node = SingleNode(item)        count = 0        # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置        pre = self._head        while count &lt; (pos-1):            count += 1            pre = pre.next        # 先将新节点node的next指向插入位置的节点        node.next = pre.next        # 将插入位置的前一个节点的next指向新节点        pre.next = node\n删除节点\ndef remove(self,item):    \"\"\"删除节点\"\"\"    cur = self._head    pre = None    while cur != None:        # 找到了指定元素        if cur.item == item:            # 如果第一个就是删除的节点            if not pre:                # 将头指针指向头节点的后一个节点                self._head = cur.next            else:                # 将删除位置前一个节点的next指向删除位置的后一个节点                pre.next = cur.next            break        else:            # 继续按链表后移节点            pre = cur            cur = cur.next\n查找结点是否存在def search(self,item):    \"\"\"链表查找节点是否存在，并返回True或者False\"\"\"    cur = self._head    while cur != None:        if cur.item == item:            return True        cur = cur.next    return False\n测试if __name__ == \"__main__\":    ll = SingleLinkList()    ll.add(1)    ll.add(2)    ll.append(3)    ll.insert(2, 4)    print \"length:\",ll.length()    ll.travel()    print ll.search(3)    print ll.search(5)    ll.remove(1)    print \"length:\",ll.length()    ll.travel()\n链表与顺序表的对比链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。\n链表与顺序表的各种操作复杂度如下所示：\n\n\n\n\n操作\n链表\n顺序表\n\n\n\n\n访问元素\nO(n)\nO(1)\n\n\n在头部插入/删除\nO(1)\nO(n)\n\n\n在尾部插入/删除\nO(n)\nO(1)\n\n\n在中间插入/删除\nO(n)\nO(n)\n\n\n\n\n注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。\n","categories":["Data Structure & Algorithm"],"tags":["Python","Data Structe"]},{"title":"Python中下划线的5种含义","url":"/2023/07/21/Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/","content":"Python中下划线的5种含义\n单前导下划线：_var\n单末尾下划线：var_\n双前导下划线：__var\n双前导和末尾下划线：var\n单下划线：_\n\n\n在文章结尾处，你可以找到一个简短的”速查表”，总结了五种不同的下划线命名约定及其含义，以及一个简短的视频教程，可让你亲身体验它们的行为。\n让我们马上开始！\n1. 单前导下划线 _var当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python社区一致认为它应该是什么意思，但程序的行为不受影响。\n下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。\n这不是Python强制规定的。 Python不像Java那样在”私有”和”公共”变量之间有很强的区别。 这就像有人提出了一个小小的下划线警告标志，说：\n“嘿，这不是真的要成为类的公共接口的一部分。不去管它就好。”\n看看下面的例子：\nclass Test:   def __init__(self):       self.foo = 11       self._bar = 23\n如果你实例化此类，并尝试访问在init构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看：\n&gt;&gt;&gt; t = Test()&gt;&gt;&gt; t.foo11&gt;&gt;&gt; t._bar23\n你会看到_bar中的单个下划线并没有阻止我们”进入”类并访问该变量的值。\n这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。\n但是，前导下划线的确会影响从模块中导入名称的方式。\n假设你在一个名为my_module的模块中有以下代码：\n# This is my_module.py:def external_func():   return 23def _internal_func():   return 42\n现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的all列表）：\n&gt;&gt;&gt; from my_module import *&gt;&gt;&gt; external_func()23&gt;&gt;&gt; _internal_func()NameError: \"name '_internal_func' is not defined\"\n顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。\n与通配符导入不同，常规导入不受前导单个下划线命名约定的影响：\n&gt;&gt;&gt; import my_module&gt;&gt;&gt; my_module.external_func()23&gt;&gt;&gt; my_module._internal_func()42\n我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个：\n单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。\n2. 单末尾下划线 var_有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：\n&gt;&gt;&gt; def make_object(name, class):SyntaxError: \"invalid syntax\"&gt;&gt;&gt; def make_object(name, class_):...    pass\n总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。\n3. 双前导下划线 __var到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。\n双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。\n这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。\n我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明：\nclass Test:   def __init__(self):       self.foo = 11       self._bar = 23       self.__baz = 23\n让我们用内置的dir()函数来看看这个对象的属性：\n&gt;&gt;&gt; t = Test()&gt;&gt;&gt; dir(t)['_Test__baz', '__class__', '__delattr__', '__dict__', '__dir__','__doc__', '__eq__', '__format__', '__ge__', '__getattribute__','__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__','__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__','__setattr__', '__sizeof__', '__str__', '__subclasshook__','__weakref__', '_bar', 'foo']\n以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称foo，_bar和__baz - 我保证你会注意到一些有趣的变化。\nself.foo变量在属性列表中显示为未修改为foo。\nself._bar的行为方式相同 - 它以_bar的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。 然而，对于self.baz而言，情况看起来有点不同。 当你在该列表中搜索baz时，你会看不到有这个名字的变量。\n__baz出什么情况了？\n如果你仔细观察，你会看到此对象上有一个名为_Test__baz的属性。 这就是Python解释器所做的名称修饰。 它这样做是为了防止变量在子类中被重写。\n让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性：\nclass ExtendedTest(Test):   def __init__(self):       super().__init__()       self.foo = 'overridden'       self._bar = 'overridden'       self.__baz = 'overridden'\n现在，你认为foo，_bar和__baz的值会出现在这个ExtendedTest类的实例上吗？ 我们来看一看：\n&gt;&gt;&gt; t2 = ExtendedTest()&gt;&gt;&gt; t2.foo'overridden'&gt;&gt;&gt; t2._bar'overridden'&gt;&gt;&gt; t2.__bazAttributeError: \"'ExtendedTest' object has no attribute '__baz'\"\n等一下，当我们尝试查看t2 . baz的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有baz属性：\n&gt;&gt;&gt; dir(t2)['_ExtendedTest__baz', '_Test__baz', '__class__', '__delattr__','__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__','__getattribute__', '__gt__', '__hash__', '__init__', '__le__','__lt__', '__module__', '__ne__', '__new__', '__reduce__','__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__','__subclasshook__', '__weakref__', '_bar', 'foo', 'get_vars']\n正如你可以看到baz变成_ExtendedTestbaz以防止意外修改：\n&gt;&gt;&gt; t2._ExtendedTest__baz'overridden'\n但原来的_Test__baz还在：\n&gt;&gt;&gt; t2._Test__baz42\n双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点：\nclass ManglingTest:   def __init__(self):       self.__mangled = 'hello'   def get_mangled(self):       return self.__mangled&gt;&gt;&gt; ManglingTest().get_mangled()'hello'&gt;&gt;&gt; ManglingTest().__mangledAttributeError: \"'ManglingTest' object has no attribute '__mangled'\"\n名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（”dunders”）开头的所有名称：\nclass MangledMethod:   def __method(self):       return 42   def call_it(self):       return self.__method()&gt;&gt;&gt; MangledMethod().__method()AttributeError: \"'MangledMethod' object has no attribute '__method'\"&gt;&gt;&gt; MangledMethod().call_it()42\n这是另一个也许令人惊讶的运用名称修饰的例子：\n_MangledGlobal__mangled = 23class MangledGlobal:   def test(self):       return __mangled&gt;&gt;&gt; MangledGlobal().test()23\n在这个例子中，我声明了一个名为_MangledGlobalmangled的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以mangled来引用_MangledGlobal__mangled全局变量。\nPython解释器自动将名称mangled扩展为_MangledGlobalmangled，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。\n有很多要吸收的内容吧。\n老实说，这些例子和解释不是从我脑子里蹦出来的。我作了一些研究和加工才弄出来。我一直使用Python，有很多年了，但是像这样的规则和特殊情况并不总是浮现在脑海里。\n有时候程序员最重要的技能是”模式识别”，而且知道在哪里查阅信息。如果您在这一点上感到有点不知所措，请不要担心。慢慢来，试试这篇文章中的一些例子。\n让这些概念完全沉浸下来，以便你能够理解名称修饰的总体思路，以及我向您展示的一些其他的行为。如果有一天你和它们不期而遇，你会知道在文档中按什么来查。\n4. 双前导和双末尾下划线 var也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改：\nclass PrefixPostfixTest:   def __init__(self):       self.__bam__ = 42&gt;&gt;&gt; PrefixPostfixTest().__bam__42\n但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，init对象构造函数，或call —- 它使得一个对象可以被调用。\n这些dunder方法通常被称为神奇方法 - 但Python社区中的许多人（包括我自己）都不喜欢这种方法。\n最好避免在自己的程序中使用以双下划线（”dunders”）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。\n5.单下划线 _按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。\n例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用”_”来表示它只是一个临时值：\n&gt;&gt;&gt; for _ in range(32):...    print('Hello, World.')\n你也可以在拆分(unpacking)表达式中将单个下划线用作”不关心的”变量，以忽略特定的值。 同样，这个含义只是”依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。\n在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，”_”作为占位符变量可以派上用场：\n&gt;&gt;&gt; car = ('red', 'auto', 12, 3812.4)&gt;&gt;&gt; color, _, _, mileage = car&gt;&gt;&gt; color'red'&gt;&gt;&gt; mileage3812.4&gt;&gt;&gt; _12\n除了用作临时变量之外，”_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。\n这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：\n&gt;&gt;&gt; 20 + 323&gt;&gt;&gt; _23&gt;&gt;&gt; print(_)23&gt;&gt;&gt; list()[]&gt;&gt;&gt; _.append(1)&gt;&gt;&gt; _.append(2)&gt;&gt;&gt; _.append(3)&gt;&gt;&gt; _[1, 2, 3]\nPython下划线命名模式 - 小结以下是一个简短的小结，即”速查表”，罗列了我在本文中谈到的五种Python下划线模式的含义：\n\n"},{"title":"C++函数","url":"/2023/07/23/C++%E5%87%BD%E6%95%B0/","content":"\n"},{"title":"坐标转换","url":"/2023/07/20/%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/","content":"坐标转换\n地平坐标系转换为赤道坐标系输入\n方位角Azimuth(deg):A\n\n高度角Altitude/Elevation(deg):E\n\n纬度(latitude):\n\n输出\n时角:HA\n赤纬:Dec\n\n转换矩阵\n\\begin{align}\nx &= - \\cos A * \\cos E* \\sin \\phi + \\sin E * \\cos \\phi \\\\\ny &= - \\sin A * \\cos E \\\\\nz &= \\cos A * \\cos E * \\cos \\phi + \\sin E * \\sin \\Phi\n\\end{align}赤道坐标\n\\begin{align}\nHA &= \\arctan \\frac{y}{x}  \\\\\nDec &= \\arctan \\frac{z}{\\sqrt{x^2+y^2}}\n\\end{align}本地恒星时( local Sidereal Time)ephem计算LSTimport ephemgatech = ephem.Observer()gatech.lon, gatech.lat = '-84.39733', '33.775867'gatech.date = '1978/10/3 11:32'print(gatech.sidereal_time())\n"},{"title":"主动光学与自适应光学","url":"/2024/01/01/%E4%B8%BB%E5%8A%A8%E5%85%89%E5%AD%A6%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E5%85%89%E5%AD%A6/","content":"主动光学与自适应光学前番的《关于望远镜镜坯》一文提到了目前望高面型精度反射镜的制造，但质量再好的望远镜也不可避免地受到重力、温度、大气湍动等因素的影响。对时下流行的弯月形薄镜面来说，自身的厚度不足以抵抗重力变形；而地球上最好的台址也不能完全克服大气的干扰：仅仅是对于4米望远镜，大气扰动就可以使其极限星等比衍射极限亮一等了。如此情况下，想要提高分辨率，增大望远镜口径和保证磨制精度固然重要，上述几个不利因素也必须要设法克服。\n\n主动光学（Active Optics）和自适应光学（Adaptive Optics）就是以上问题的解决途径，二者在原理上有相似之处，干脆放在一起写好了。\n不过首先要解释的是这两种技术的区别。早先本人一直是把二者混为一谈的，直到看到课本上将这两个名词并列印在一起，才意识到自己是犯了很多年的错误。主动光学是在1980年代发展起来的，它是在薄型主镜后方设有上百个计算机控制的促动器，随时监测并抵消重力变形、风力干扰和温度波动对成像的影响，调整频率约0.01至1赫兹。自适应光学主要补偿的则是大气湍动，调整频率可达每秒上百次，调整的对象也非主镜，而是光路中专门设置的一块变形辅助镜（大口径主镜难以承受高频调整）。\n不论是主动光学还是自适应光学，工作时都需要实时检测星象。检测装置常采用沙克-哈特曼（Shack-Hartmann）光栏，这是一组小透镜组成的阵列，根据成像可以计算出各点上波前的扭曲程度并求得相应的改正量。此装置的一大优点是，待测天体不一定是点源，就算是太阳这样变化迅速的天体也照样可用（因此目前有一些太阳望远镜也采用了自适应光学系统）。沙克-哈特曼光栏的具体工作原理可参考实测天体物理学的相关书籍，在此不赘述。\n以下分别说说主动光学和自适应光学技术。\n　\n主动光学\n主动光学系统工作原理图。（图片提供：Ed Janssen, ESO）\n最初运用主动光学系统的望远镜包括北欧光学望远镜、欧洲南方天文台新技术望远镜等中等口径设备，其中后者于1989年投入使用，是第一架全面采用主动光学技术的望远镜。所谓主动是相对传统的刚性厚反射镜而言的，后者并没有装配改善成像的设备，只是通过提高机械强度被动克服重力等不利影响。主动光学系统可以让望远镜主镜时刻保持最佳状态，克服影响成像的因素中与面形有关的一部分，故有“主动”之名。\n使用主动光学的望远镜需要在光路中分出一束光线，将其引入沙克-哈特曼光栏检测装置。计算机检测出像差，计算准泽尼克多项式的系数，利用其与预先校正值之差来调整各促动器施力大小，并实时反馈。有的望远镜也备有开环改正机制，需要了解望远镜的受力和位置，适用于引导星亮度不足或是检测装置失灵等情况下的使用。\n\n昴星团望远镜背面的促动器阵列。（图片提供：NAOJ）\n而对于凯克望远镜这样的拼接镜面，主动光学系统更是保持面型的必需装置。由于单块子镜直径不大，受环境影响较小，故调节的重点不是子镜的面形，而是相对位置。凯克望远镜在这一点上是使用电容式的传感器来进行监测的。中国在建的LAMOST望远镜由于在观测不同的天体时需要不同的面形，也配备有主动光学系统来将改正板调整到所需要的形状上，这比单纯校正面型的传统主动光学又进了一步。实际上主动光学已用在了几乎所有新建的大中型望远镜上，可以将镜面精度保持在100埃或更高的量级上。\n\n凯克望远镜的促动器分布，图中可见各子镜的接缝处是重点调整对象，子镜上的促动器则用于调节彼此的相对高度。\n除用于望远镜系统外，主动光学还可以在法布里—珀罗干涉仪上使用。\n　\n自适应光学\n自适应光学系统工作原理图。（图片来源：Answers.com）\n自适应光学是Horace Babcock于1953年提出的，其原理并不复杂，小型试验也早在1960年代末就在威尔逊天文台进行过，观测对象为木星和土星。不过该技术的大范围运用要等到计算机和光学设计技术发达后的1990年代，其中SDI计划的解密对其起了很大的推动作用。与主动光学不同，自适应光学是依照大气湍动情况调整反射镜面形，以改正出射波前，而非将面形保持在最佳状态上。使用自适应光学后，望远镜的分辨率可以提高10倍以上。\n\n自适应光学使用前（左）与使用后（右）拍摄的同一星团对比，左图分辨率约0.6角秒，右图为0.09角秒。（图片提供：Gemini Observatory, National Science Foundation, and the University of Hawai’i Adaptive Optics Group）\n不过自适应光学的工作原理与主动光学还是比较类似的，也是从主光路中分束检测，通常是选择待测天体附近的一颗亮星作校准用引导星。计算机控制促动器调整的则是变形辅助镜。变形镜一般安置在望远镜焦点后方，口径8至20厘米，设有数百个促动器。促动器的具体数目取决于要求的调整精度和引导星的亮度，当然还有预算。\n\n昴星团望远镜的自适应光学变形镜系统，安装在卡塞格林焦点处。（图片提供：NAOJ）\n显然，对引导星的要求大大限制了自适应光学系统的观测范围，因为并非所有待测天体附近都有符合要求的亮星（亮度不低于12-15等），而且引导星与目标距离过大也会由于彼此大气湍动情况不同而使像质严重恶化。而小口径的变形镜也使自适应光学难以一次观测很大的天区，轻易加大变形镜又会带来一系列机械和材料方面的问题，如镜面碎裂的克服（大型双筒望远镜的变形镜就曾由于承受不住高频变化而破碎）。\n这两个缺陷的解决方案分别是激光引导星和多共轭点（Multi-Conjugate）自适应光学系统。前者是向大气中间层发射激光，激发钠原子辐射出黄光，产生人工引导星。目前凯克、双子、昴星团、加拿大-法国-夏威夷望远镜、欧洲南方天文台等处均配备了激光引导星系统。不过这固然解决了引导星数量不足的问题，却也引来不少新麻烦：精确控制激光投射方位的难度、路过的飞机和卫星、较大的功率（意味着开支的大大增加）、每晚的军方批准，外加彼此的冲撞。至于后者，是在光路中设置数个变形镜来增大视场。另外大口径变形镜也正在开发中。\n但由于调整频率过高、计算量过大以及对促动器需求量过多，目前自适应光学系统一般仅用于红外观测。举例来说，根据欧洲南方天文台的估计，如要使用自适应光学进行可见光观测，每架8米望远镜需要6000余个促动器，成本高不算，如何安置也是个不小的问题。但可见光的自适应光学系统已经为侦察卫星搭载的小口径望远镜所采用。\n　\n主动光学和自适应光学是现代大型地面望远镜的制胜法宝。凭借这两项技术，衍射极限不再是空想，而地面望远镜的表现也足以胜过空间望远镜。当然，技术目前并不成熟，特别是自适应光学，需要解决的问题仍旧很多，激光引导星与多共轭点自适应光学也仍处在发展初期，但凭借主动光学和自适应光学已经取得了许多新发现，而对于未来计划中的数十米乃至上百米的巨型望远镜，这二者更是必备的。\n　\n参考资料：\n[1] An introduction to Active &amp; Adaptive Optics[2] The VLT Active Optics System[3] Mauna Kea不再闪烁的星光[4] Adaptive Optics - Straightening Out Bent Starlight[5] Dr. Olivier Lai’s View Graphs on Adaptive Optics[6] 《实测天体物理学》，郑兴武 编\n\n原文链接：http://bzhang.lamost.org/website/archives/modern_instr_ao/\n\n","categories":["Astrophysical Techniques"],"tags":["主动光学","自适应光学"]},{"title":"Git 创建仓库","url":"/2024/02/19/Git-%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93/","content":"Git 创建仓库git initGit 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。\n在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。\n\n使用方法使用当前目录作为 Git 仓库，我们只需使它初始化。\ngit init\n该命令执行完后会在当前目录生成一个 .git 目录。\n使用我们指定目录作为Git仓库。\ngit init newrepo\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：\n$ git add *.c$ git add README$ git commit -m '初始化项目版本'\n以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。\n\n注： 在 Linux 系统中，commit 信息使用单引号 ‘，Windows 系统，commit 信息使用双引号 “。\n所以在 git bash 中 git commit -m ‘提交说明’ 这样是可以的，在 Windows 命令行中就要使用双引号 git commit -m “提交说明”。\n\n\ngit clone我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。\n克隆仓库的命令格式为：\ngit clone &lt;repo&gt;\n如果我们需要克隆到指定的目录，可以使用以下命令格式：\ngit clone &lt;repo&gt; &lt;directory&gt;\n参数说明：\n\nrepo:Git 仓库。\ndirectory:本地目录。\n\n比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：\n$ git clone git://github.com/schacon/grit.git\n执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。\n如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n$ git clone git://github.com/schacon/grit.git mygrit\n配置git 的设置使用 git config 命令。\n显示当前的 git 配置信息：\n$ git config --listcredential.helper=osxkeychaincore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=true\n编辑 git 配置文件:\n$ git config -e    # 针对当前仓库 \n或者：\n$ git config -e --global   # 针对系统上所有仓库\n设置提交代码时的用户信息：\n$ git config --global user.name \"runoob\"$ git config --global user.email test@runoob.com\n如果去掉 —global 参数只对当前仓库有效。\n","categories":["Git"],"tags":["Git"]},{"title":"Git工作区、暂存区和版本库","url":"/2024/02/19/Git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93/","content":"Git工作区、暂存区和版本库基本概念我们先来理解下Git工作区、暂存区和版本库概念：\n\n工作区：就是你在电脑里能看到的目录\n暂存区：英文名叫stage和index。一般存放在.git目录下面的index文件（git/index）中，所以我们把暂存区有时也叫作索引（index）\n版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\n\n\n下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：\n\n图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。\n\n图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。\n\n图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。\n\n当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。\n\n当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。\n\n当执行git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。\n\n当执行 git rm --cached &lt;file&gt; 命令时，会直接从暂存区删除文件，工作区则不做出改变。\n\n当执行 git checkout .或者git checkout -- &lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。\n\n当执行 git checkout HEAD . 或者 git checkout HEAD &lt;file&gt;命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。\n\n\n","categories":["Git"],"tags":["Git"]},{"title":"程序设计基础","url":"/2023/07/21/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","content":"程序设计基础程序设计方法与风格\n相关术语\n程序：将计算机语言代码依据一定的语法规则，描述为完成特定任务的算法的指令序列，程序执行的效率与数据的存储结构密切相关\n程序设计：程序设计为完成一项程序工作的过程\n计算机语言：计算机语言是人与计算机交流的工具\nWirth公式：算法+数据结构=程序\n\n\n\n\n\n良好的程序设计风格：清晰第一，效率第二\n源程序内部文档化\n选择标识符的名字\n程序的视觉组织\n程序的注释\n功能性注释：位于模块内部，用于描述其后语句或程序主要功能\n序言性注释：位于模块首部，用于说明模块的相关信息（程序的标题 功能的说明 主要的算法 模块接口 开发历史 程序设计者 复审者 复审日期 修改日期）\n\n\n\n\n数据说明\n数据说明的次序规范化\n说明语句中变量安排有序化\n使用注释来说明复杂数据的结构\n\n\n语句的结构\n在一行内只写一条语句\n程序编写应优先考虑清晰性\n程序编写要做到清晰第一，效率第二\n在保证程序正确的基础上再要求提高效率\n避免使用临时变量而使程序的可读性下降\n避免不必要的转移\n尽量使用库函数\n避免采用复杂的条件语句\n尽量减少使用“否定”条件语句\n数据结构要有利于程序的简化\n要模块化，使模块功能尽可能单一化\n利用信息隐蔽，确保每一个模块的独立性\n从数据出发去构造程序\n不要修补不好的程序，要重新编写\n\n\n输入和输出\n对输入数据检验数据的合法性\n检查输入项的各种重要组合的合法性\n输入格式要简单，使得输入的步骤和操作尽可能简单\n输入数据时，应允许使用自由格式\n应允许缺省值\n输入一批数据时，最好使用输入结束标志\n在以交互式输入/输出方式进行输入时，要在屏幕上使用提示符明确提示输入的请求，同时在数据输入过程中和输入结束时，应在屏幕上给出状态信息\n当程序设计语言对输入格式有严格要求时，应保持输入格式与输入语句的一致性，给所有的输出加注释，并设计输出报表格式\n\n\n\n\n\n\n良好程序设计风格不仅有助于提高程序的可靠性、可理解性、可测试性、可维护性和可重复性，而且也能够促进技术的交流，改善软件的质量\n\n结构化程序设计\n软件设计的基本原则：抽象、信息隐蔽、模块化、局部化、确定性、一致性、完备性、可靠性\n结构化程序设计风格：程序结构良好、易读性好、易测试、易维护（最强调的是易读性）\n结构化程序设计原则\n自顶向下：先考虑总体，后考虑细节；先考虑全局目标，后考虑局部目标\n逐步求精：对复杂问题，先设计一个目标作为过渡，然后逐步细化\n模块化：把程序要解决的总目标分解为一个一个的模块\n限用goto语句：程序的质量与goto语句数量成反比\n\n\n结构化程序的基本结构：顺序、选择（分支）、循环（重复）\n程序设计语言的基本成分：数据成分、运算成分、控制成分、传输成分\n\n\n设计程序时，应采纳的原则之一是程序结构应有助于读者理解（强调程序易读性）\n\n面向对象的程序设计\n面向对象方法的主要优点\n与人类习惯的思维方法致\n稳定性好\n可重用性好\n易于开发大型软件产品\n可维护性好\n\n\n\n\n与传统的的面向过程的方法不同之处：\n面向对象的程序设计主张从客观世界固有的物质出发来构造系统，使用现实世界的概念抽象地思考问题从而自然地解决问题，它提倡用人类在现实生活中常用的思维方式来认识理解描述客观事物\n\n\n对象有关概念术语\n\n对象：在现实世界中，每个实体都是对象（大学生、汽车、电视机、空调）\n\n属性：用于描述对象的状态\n\n方法：用于描述对象的行为\n\n类：一组具有相同属性和相同操作的对象的集合\n\n消息：是一个实例与另一个实例之间传递的信息，\n对象间的通信靠消息传递\n\n接收消息的对象的名称\n消息标识符，也称消息名\n零个或多个参数\n\n\n\n\n对象的基本特点\n\n标识唯一性：对象可由内在本质来区分，而不是通过描述来区分\n分类性：可以将具有相同属性和操作的对象抽象成类\n多态性：同一操作可以是不同对象的行为，同样的消息被不同对象接受时可导致完全不同的行为的现象\n封装性：从外面看不到对象的内部，只能看到对象外部特征，实现信息隐蔽，是数据与操作的结合，是属性与方法的封装\n模块独立性好：对象是面向对象的软件的基本模块，高内聚低耦合\n继承性：使用已有的类建立新类的定义技术，能直接获得已有的性质，而不必重复定义他们，是类之间共享属性和操作的机制\n依赖性：某个对象的功能依赖于另外的某个对象，而被依赖的对象只是作为一种工具在使用，而并不持有对它的引用\n\n\n\n\n“对象是属性和方法的封装体”、“任何对象不一定有继承性”\n“对象是类的具体实例，类是对象的抽象”、“操作是对象的动态属性”\n基于同一类产生的对象可以分别设置各自的属性，对象中的属性只能通过该对象所提供的操作来存取或修改\n\n","categories":["Data Structure & Algorithm"],"tags":["Python","Data Structe"]},{"title":"惠更斯原理","url":"/2024/03/10/%E6%83%A0%E6%9B%B4%E6%96%AF%E5%8E%9F%E7%90%86/","content":"几何光学几何光学（也称为射线光学）是研究光的传播路径（射线）的光学分支，主要应用于解释和计算光通过透镜、反射镜等光学元件时的行为。几何光学基于一些简化的假设，忽略光的波动性，主要关注光线如何在不同介质中直线传播以及在界面上发生反射和折射。\n\n几何光学三大定律\n光线直线传播定律：在同一均匀介质中，光线沿直线传播。这是几何光学中最基本的原理，它说明在没有其他物质影响光线传播的情况下（如在真空或均匀介质中），光线会沿直线路径前进。\n反射定律：当光线从一种介质入射到另一种介质的界面上时，如果光线被界面反射回原来的介质，那么入射光线、反射光线和界面上的法线都处在同一平面内，并且入射角等于反射角。入射角和反射角都是相对于垂直于界面的法线测量的。\n折射定律（斯涅尔定律）：当光线从一种介质入射到另一种介质时，除了反射光线外，还有一部分光线会进入第二种介质，并且改变其传播方向（即折射）。入射光线、折射光线和界面上的法线都处于同一平面内。入射角（i）和折射角（r）之间的关系遵循斯涅尔定律，即n₁sin(i) = n₂sin(r)，其中n₁和n₂是两种介质的折射率。\n\n惠更斯原理惠更斯原理（Huygens’ principle）是一个物理学原理，由17世纪荷兰物理学家克里斯蒂安·惠更斯（Christian Huygens）提出。该原理解释了波的传播方式，特别是对于光波和声波的传播。惠更斯原理可以总结为以下几点：\n\n每个点都可以被视为是次级波源：在波传播的过程中，每个波的传播速度相同的波前上的每一点都可以被视为是次级波源，它会发射新的波。这意味着波在传播的过程中，波前上的每个点都会向各个方向发射新的波。\n\n波的传播可以看作是波前的延伸：通过惠更斯原理，我们可以将波的传播看作是波前不断扩展的过程。每个波前上的点都会作为波源发射新的波，从而使得波前不断向前延伸。\n\n新波的相干叠加：在波的传播过程中，新波与原始波相干叠加，形成新的波前。这种叠加使得波的传播路径可以用来解释许多波的现象，例如衍射和干涉。\n\n\n惠更斯原理在光学、声学以及其他波动现象的研究中起着重要作用，帮助我们理解波的传播方式以及各种波现象的特性。\n\n费马原理在几何光学中，费马原理是一个基本原理，用于描述光线在光学系统中的传播路径。费马原理在这个领域通常是这样表述的：\n光线在传播过程中沿着路径取使光程或光程差取极值的方式传播。\n光程（或光程差）是光线在传播过程中所经过的路径长度与介质折射率的乘积。费马原理告诉我们，光线在光学系统中的传播路径不是任意的，而是会选择一条使得光程或光程差取极值的路径。这通常导致光线遵循一些简单的规律，如折射定律和反射定律。\n费马原理在几何光学中是一个重要的工具，可以用来分析光学系统中的成像、透镜、反射器等问题。通过费马原理，可以推导出像的位置、焦距等重要的光学性质，从而帮助我们设计和理解光学系统。\n","categories":["Optics"],"tags":["geometrical optics"]},{"title":"Astrophysical Techniques:探测器","url":"/2024/02/21/Astrophysical-Techniques-%E6%8E%A2%E6%B5%8B%E5%99%A8/","content":"Astrophysical Techniques：探测器探测器分类概要\n\n\n\n敏感参量\n探测器名称\n类别\n\n\n\n\n电压\n光伏管\n量子\n\n\n\n热电偶\n热学\n\n\n\n热电探测器\n热学\n\n\n电阻\n阻杂带器件（BIB）\n量子\n\n\n\n测热辐射计\n热学\n\n\n\n光导管\n量子\n\n\n\n光敏晶体管\n量子\n\n\n\n临界边缘传感器（TES）\n热学\n\n\n电荷\n电荷耦合器件（CCD）\n量子\n\n\n\n电荷注入器件（CID）\n量子\n\n\n电流\n超导隧道结（STJ）\n量子\n\n\n电子激发\n照相乳胶\n量子\n\n\n电子发射\n光电倍增管\n量子\n\n\n\n电视\n量子\n\n\n\n像增强器\n量子\n\n\n化学成分\n眼睛\n量子\n\n\n\n\n\n评价和比较探测器的某些指标\n\n\n\n评价指标\n\n\n\n\n\nQE（量子效率）\n\n\n\nDQE（探测量子效率）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Astropysical Techniques"],"tags":["Astropysical Techniqu"]},{"title":"python28种极坐标绘图函数总结","url":"/2024/05/16/python28%E7%A7%8D%E6%9E%81%E5%9D%90%E6%A0%87%E7%BB%98%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/","content":"matplotlib中的画图函数，大部分情况下只要声明坐标映射是polar，就都可以画出对应的极坐标图。但极坐标和直角坐标的坐标区间不同，所以有些数据和函数关系适合在直角坐标系中展示，而有些则适合在及坐标中展示。\n\n\n\n\n\n函数\n坐标参数\n图形类别\n\n\n\n\nplot\nx,y\n曲线图\n\n\nstackplot\nx,y\n散点图\n\n\nstem\nx,y\n茎叶图\n\n\nscatter\nx,y\n散点图\n\n\npolar\nx,y\n极坐标图\n\n\nstep\nx,y\n步阶图\n\n\nbar\nx,y\n条形图\n\n\nbarh\nx,y\n横向条形图\n\n\n\n\n\nbar和barh的对偶关系稍微有些抽象，可以理解为前者是以角度方向为x轴；而barh则是以半径方向为x轴。\n代码如下\nimport matplotlib.pyplot as pltimport numpy as npx = np.arange(20)/2y = xfDct = {\"plot\" : plt.plot,  \"stackplot\": plt.stackplot,        \"stem\" : plt.stem,  \"scatter\"  : plt.scatter,                 \"polar\": plt.polar, \"step\"     : plt.step,         \"bar\"  : plt.bar,   \"barh\"     : plt.barh, }fig = plt.figure(figsize=(14,6))for i,key in enumerate(fDct, 1):    ax = fig.add_subplot(2,4,i, projection=\"polar\")    fDct[key](x, y)    plt.title(key)plt.tight_layout()plt.show()\n误差线\n\n\n\n\n函数\n坐标\n图形类别\n\n\n\n\nerrorbar\nx,y,xerr,yerr\n误差线\n\n\nfill_between\nx,y1,y2\n纵向区间图\n\n\nfill_betweenx\ny, x1, x2\n横向区间图\n\n\n\n\n\n代码如下\nx = np.arange(20)/2y = xy1, y2 = 0.9*y, 1.1*yx1, x2 = 0.9*x, 1.1*xxerr = np.abs([x1, x2])/10yerr = np.abs([y1, y2])/10fig = plt.figure(figsize=(12,4))ax = fig.add_subplot(141, projection='polar')ax.errorbar(x, y, yerr=yerr)plt.title(\"errorbar with yerr\")ax = fig.add_subplot(142, projection='polar')ax.errorbar(x, y, xerr=xerr)plt.title(\"errorbar with xerr\")ax = fig.add_subplot(143, projection='polar')ax.fill_between(x, y1, y2)plt.title(\"fill_between\")ax = fig.add_subplot(144, projection='polar')ax.fill_betweenx(y, x1, x2)plt.title(\"fill_betweenx\")plt.tight_layout()plt.show()\n等高线polar\n\n\n\n\n绘图函数\n坐标\n说明\n\n\n\n\ncontour\n[x,y,]z\n等高线\n\n\ncontourf\n[x,y,]z\n填充等高线\n\n\npcolormesh\n[x,y,]z\n伪彩图\n\n\n\n\n由于imshow默认其绘图坐标是标准的1x1网格，而在极坐标种，这种网格的尺寸会随着r的增大而增大，从而变得极其不实用，所以下面对极坐标图的演示，就不包含imshow了。\n\n代码如下\nX, Y = np.indices([100,100])X = X/100*np.pi*2Y = Y/25 - 2Z = (1 - np.sin(X) + np.cos(X)**5 + Y**3) * np.exp(-Y**2)fDct = {\"contour\": plt.contour, \"contourf\":plt.contourf,     \"pcolormesh\" : plt.pcolormesh}fig = plt.figure(figsize=(9,3))for i,key in enumerate(fDct, 1):    ax = fig.add_subplot(1,3,i, projection='polar')    fDct[key](X,Y,Z)    plt.title(key)plt.tight_layout()plt.show()\n场图polar\n\n\n\n\n绘图函数\n坐标\n说明\n\n\n\n\nquiver\nx,y,u,v\n向量场图\n\n\nstreamplot\nx,y,u,v\n流场图\n\n\nbarbs\nx,y,u,v\n风场图\n\n\n\n\n\n代码如下\nY, X = np.indices([10,10])X = X/10*np.pi*2.5Y = Y#Y, X = np.indices([6,6])/0.75 - 4U = 6*np.sin(X) + YV = Y - 6*np.sin(X)dct = {\"quiver\":plt.quiver, \"streamplot\":plt.streamplot,        \"barbs\" :plt.barbs}fig = plt.figure(figsize=(12,4))for i,key in enumerate(dct, 1):    ax = fig.add_subplot(1,3,i,projection='polar')    dct[key](X,Y,U,V)    plt.title(key)plt.tight_layout()plt.show()\n统计图\n\n\n\n\n绘图函数\n坐标\n说明\n\n\n\n\nhist\nx\n数据直方图\n\n\nboxplot\nx\n箱线图\n\n\nviolinplot\nx\n小提琴图\n\n\nenventplot\nx\n平行线疏密图\n\n\nhist2d\nx,y\n二维直方图\n\n\nhexbin\nx,y\n钻石图\n\n\npie\nx\n饼图\n\n\n\n\n极坐标在绘制直方图的时候，需要注意其横坐标是以为周期的，也就是说随机变量的最大值和最小值不得相差 ，否则会导致重叠。\n\n由于极坐标绘图本质上是一种坐标映射，所以并不会把0和360°真正地等同起来，所以在hist2d中，整个图像并没有闭合。而最有意思的是饼图，直接给压扁了，让人很难一下子看出不同组分的比例关系。\n代码如下\nx = np.random.standard_normal(size=1000)dct = {\"hist\"  : plt.hist, \"violinplot\" : plt.violinplot,      \"boxplot\": plt.boxplot}fig = plt.figure(figsize=(10,6))for i,key in enumerate(dct, 1):    ax = fig.add_subplot(2,3,i, projection='polar')    dct[key](x)    plt.title(key)ax = fig.add_subplot(234, projection='polar')ax.eventplot(x)plt.title(\"eventplot\")x = np.random.randn(5000)y = 1.2 * x + np.random.randn(5000) / 3ax = fig.add_subplot(235, projection='polar')ax.hist2d(x, y, bins=[np.arange(-3,3,0.1)] * 2)plt.title(\"hist2d\")ax = fig.add_subplot(236, projection='polar')ax.pie([1,2,3,4,5])plt.title(\"pie\")plt.tight_layout()plt.show()\n非结构坐标图\n\n\n\n\n绘图函数\n坐标\n说明\n\n\n\n\ntricontour\nx,y,z\n非结构等高线\n\n\ntricontourf\nx,y,z\n非结构化填充等高线\n\n\ntricolor\nx,y,z\n非结构化伪彩图\n\n\ntriplot\nx,y\n三角连线图\n\n\n\n\n\n代码如下\nx = np.random.uniform(0, np.pi*2, 256)y = np.random.uniform(-2, 2, 256)z = (1 - np.sin(x) + np.cos(x)**5 + y**3) * np.exp(-y**2)levels = np.linspace(z.min(), z.max(), 7)fig = plt.figure(figsize=(12,4))ax = fig.add_subplot(141, projection='polar')ax.plot(x, y, 'o', markersize=1, color='lightgrey', alpha=0.5)ax.tricontour(x, y, z, levels=levels)plt.title(\"tricontour\")ax = fig.add_subplot(142, projection='polar')ax.plot(x, y, 'o', markersize=1, color='lightgrey', alpha=0.5)ax.tricontourf(x, y, z, levels=levels)plt.title(\"tricontourf\")ax = fig.add_subplot(143, projection='polar')ax.plot(x, y, 'o', markersize=1, color='lightgrey', alpha=0.5)ax.tripcolor(x, y, z)plt.title(\"tripcolor\")ax = fig.add_subplot(144, projection='polar')ax.triplot(x,y)plt.title(\"triplot\")plt.tight_layout()plt.show()\n","categories":["Python"],"tags":["Matplotlib"]},{"title":"Maven介绍","url":"/2024/11/26/Maven%E4%BB%8B%E7%BB%8D/","content":"Maven介绍Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\nMaven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\nMaven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。\n\nMaven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：\n\n提供了一套标准化的项目结构；\n提供了一套标准化的构建流程（编译，测试，打包，发布……）；\n提供了一套依赖管理机制。\n\nMaven项目结构一个使用Maven管理的普通的Java项目，它的目录结构默认如下：\na-maven-project├── pom.xml├── src│   ├── main│   │   ├── java│   │   └── resources│   └── test│       ├── java│       └── resources└── target\n\na-maven-project是项目名，它有一个项目描述文件pom.xml\nsrc/main/java是存放Java源码的目录\nsrc/main/resources是存放资源文件的目录\nsrc/test/java是存放测试源码的目录\nsrc/test/resources是存放测试资源的目录\n最后，所有编译、打包生成的文件都存放在target目录里。这些就是一个Maven项目的标准目录结构\n\n所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。\n我们再来看最关键的一个项目描述文件pom.xml，它的内容长得像下面：\n&lt;project ...&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;\t&lt;artifactId&gt;hello&lt;/artifactId&gt;\t&lt;version&gt;1.0&lt;/version&gt;\t&lt;packaging&gt;jar&lt;/packaging&gt;\t&lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\t\t&lt;maven.compiler.release&gt;17&lt;/maven.compiler.release&gt;\t&lt;/properties&gt;\t&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;            &lt;version&gt;2.0.16&lt;/version&gt;        &lt;/dependency&gt;\t&lt;/dependencies&gt;&lt;/project&gt;\n\ngroupId类似于Java的包名，通常是公司或组织名称，\nartifactId类似于Java的类名，通常是项目名称，再加上version，\n一个Maven工程就是由groupId，artifactId和version作为唯一标识。\n\n我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖org.slfj4:slf4j-simple:2.0.16：\n&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;    &lt;version&gt;2.0.16&lt;/version&gt;&lt;/dependency&gt;\n使用&lt;dependency&gt;声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。\n另外，注意到&lt;properties&gt;定义了一些属性，常用的属性有：\n\nproject.build.sourceEncoding：表示项目源码的字符编码，通常应设定为UTF-8；\nmaven.compiler.release：表示使用的JDK版本，例如21；\nmaven.compiler.source：表示Java编译器读取的源码版本；\nmaven.compiler.target：表示Java编译器编译的Class版本。\n\n从Java 9开始，推荐使用maven.compiler.release属性，保证编译时输入的源码和编译输出版本一致。如果源码和输出版本不同，则应该分别设置maven.compiler.source和maven.compiler.target。\n通过&lt;properties&gt;定义的属性，就可以固定JDK版本，防止同一个项目的不同的开发者各自使用不同版本的JDK。\n小结Maven是一个Java项目的管理和构建工具：\n\nMaven使用pom.xml定义项目内容，并使用预设的目录结构；\n在Maven中声明一个依赖项可以自动下载并导入classpath；\nMaven使用groupId，artifactId和version唯一定位一个依赖。\n\n","categories":["Maven"],"tags":["Java,Maven"]},{"title":"Maven依赖管理","url":"/2024/11/26/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/","content":"Maven依赖管理Maven解决了依赖管理问题。例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包：\n┌──────────────┐│Sample Project│└──────────────┘        │        ▼┌──────────────┐│     abc      │└──────────────┘        │        ▼┌──────────────┐│     xyz      │└──────────────┘\n\n当我们声明了abc的依赖时，Maven自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。\n因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的jar包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。\n我们来看一个复杂依赖示例：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n当我们声明一个spring-boot-starter-web依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖：\nspring-boot-starter-web  spring-boot-starter    spring-boot    sprint-boot-autoconfigure    spring-boot-starter-logging      logback-classic        logback-core        slf4j-api      jcl-over-slf4j        slf4j-api      jul-to-slf4j        slf4j-api      log4j-over-slf4j        slf4j-api    spring-core    snakeyaml  spring-boot-starter-tomcat    tomcat-embed-core    tomcat-embed-el    tomcat-embed-websocket      tomcat-embed-core  jackson-databind  ...\n如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。\n依赖关系Maven定义了几种依赖关系，分别是compile、test、runtime和provided：\n\n\n\n\nscope\n说明\n示例\n\n\n\n\ncompile\n编译时需要用到该jar包（默认）\ncommons-logging\n\n\ntest\n编译Test时需要用到该jar包\njunit\n\n\nruntime\n编译时不需要，但运行时需要用到\nmysql\n\n\nprovided\n编译时需要用到，但运行时由JDK或某个服务器提供\nservlet-api\n\n\n\n\n其中，默认的compile是最常用的，Maven会把这种类型的依赖直接放入classpath。\ntest依赖表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是JUnit：\n&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.2&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\nruntime依赖表示编译时不需要，但运行时需要。最典型的runtime依赖是JDBC驱动，例如MySQL驱动：\n&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.48&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\nprovided依赖表示编译时需要，但运行时不需要。最典型的provided依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：\n&lt;dependency&gt;    &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;    &lt;version&gt;4.0.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;\n最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。\nMaven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。\n唯一ID对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：\n\ngroupId：属于组织的名称，类似Java的包名；\nartifactId：该jar包自身的名称，类似Java的类名；\nversion：该jar包的版本。\n\n通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。\n因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。\n注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。\n 提示：后续我们在表示Maven依赖时，使用简写形式groupId:artifactId:version，例如：org.slf4j:slf4j-api:2.0.4。\nMaven镜像除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：\n           slow    ┌───────────────────┐    ┌─────────────▶│Maven Central Repo.│    │              └───────────────────┘    │                        │    │                        │sync    │                        ▼┌───────┐  fast    ┌───────────────────┐│ User  │─────────▶│Maven Mirror Repo. │└───────┘          └───────────────────┘\n中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下：\n&lt;settings&gt;    &lt;mirrors&gt;        &lt;mirror&gt;            &lt;id&gt;aliyun&lt;/id&gt;            &lt;name&gt;aliyun&lt;/name&gt;            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;            &lt;!-- 国内推荐阿里云的Maven镜像 --&gt;            &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;        &lt;/mirror&gt;    &lt;/mirrors&gt;&lt;/settings&gt;\n配置镜像仓库后，Maven的下载速度就会非常快。\n搜索第三方组件最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制：\n\n命令行编译在命令中，进入到pom.xml所在目录，输入以下命令：\n$ mvn clean package\n如果一切顺利，即可在target目录下获得编译后自动打包的jar。\n在IDE中使用Maven几乎所有的IDE都内置了对Maven的支持。在Eclipse中，可以直接创建或导入Maven项目。如果导入后的Maven项目有错误，可以尝试选择项目后点击右键，选择Maven - Update Project…更新：\n\n小结Maven通过解析依赖关系确定项目所需的jar包，常用的4种scope有：compile（默认），test，runtime和provided；\nMaven从中央仓库下载所需的jar包并缓存在本地；\n可以通过镜像仓库加速下载。\n","categories":["Maven"],"tags":["Maven,java"]},{"title":"Maven使用插件","url":"/2024/11/26/Maven%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6/","content":"Maven使用插件我们在前面介绍了Maven的lifecycle，phase和goal：使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。每个phase会执行自己默认的一个或多个goal。goal是最小任务单元。\n\n我们以compile这个phase为例，如果执行：\n$ mvn compile\nMaven将执行compile这个phase，这个phase会调用compiler插件执行关联的compiler:compile这个goal。\n实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行compile，它只是负责找到对应的compiler插件，然后执行默认的compiler:compile这个goal来完成编译。\n所以，使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。\nMaven已经内置了一些常用的标准插件：\n\n\n\n\n插件名称\n对应执行的phase\n\n\n\n\nclean\nclean\n\n\ncompiler\ncompile\n\n\nsurefire\ntest\n\n\njar\npackage\n\n\n\n\n如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用maven-shade-plugin可以创建一个可执行的jar，要使用这个插件，需要在pom.xml中声明它：\n&lt;project&gt;    ...\t&lt;build&gt;\t\t&lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2.1&lt;/version&gt;\t\t\t\t&lt;executions&gt;\t\t\t\t\t&lt;execution&gt;\t\t\t\t\t\t&lt;phase&gt;package&lt;/phase&gt;\t\t\t\t\t\t&lt;goals&gt;\t\t\t\t\t\t\t&lt;goal&gt;shade&lt;/goal&gt;\t\t\t\t\t\t&lt;/goals&gt;\t\t\t\t\t\t&lt;configuration&gt;                            ...插件配置...\t\t\t\t\t\t&lt;/configuration&gt;\t\t\t\t\t&lt;/execution&gt;\t\t\t\t&lt;/executions&gt;\t\t\t&lt;/plugin&gt;\t\t&lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt;\n自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定Java程序的入口，它的配置是：\n&lt;configuration&gt;    &lt;transformers&gt;        &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt;            &lt;mainClass&gt;com.itranswarp.learnjava.Main&lt;/mainClass&gt;        &lt;/transformer&gt;    &lt;/transformers&gt;&lt;/configuration&gt;\n注意，Maven自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明。\n下面列举了一些常用的插件：\n\nmaven-shade-plugin：打包所有依赖包并生成可执行jar；\ncobertura-maven-plugin：生成单元测试覆盖率报告；\nfindbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。\n\n小结Maven通过自定义插件可以执行项目构建时需要的额外功能，使用自定义插件必须在pom.xml中声明插件及配置；\n插件会在某个phase被执行时执行；\n插件的配置和用法需参考插件的官方文档。\n","categories":["Maven"],"tags":["Maven,Java"]},{"title":"Maven构建流程","url":"/2024/11/26/Maven%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/","content":"Maven构建流程Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。\n\nLifecycle和Phase使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。\nMaven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase：\n\nvalidate\ninitialize\ngenerate-sources\nprocess-sources\ngenerate-resources\nprocess-resources\ncompile\nprocess-classes\ngenerate-test-sources\nprocess-test-sources\ngenerate-test-resources\nprocess-test-resources\ntest-compile\nprocess-test-classes\ntest\nprepare-package\npackage\npre-integration-test\nintegration-test\npost-integration-test\nverify\ninstall\ndeploy\n\n如果我们运行mvn package，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止：\n\nvalidate\ninitialize\n…\nprepare-package\npackage\n\n如果我们运行mvn compile，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase：\n\nvalidate\ninitialize\n…\nprocess-resources\ncompile\n\nMaven另一个常用的生命周期是clean，它会执行3个phase：\n\npre-clean\nclean （注意这个clean不是lifecycle而是phase）\npost-clean\n\n所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。\n更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下：\n\npre-clean\nclean （注意这个clean是phase）\nvalidate （开始执行default生命周期的第一个phase）\ninitialize\n…\nprepare-package\npackage\n\n在实际开发过程中，经常使用的命令有：\nmvn clean：清理所有生成的class和jar；\nmvn clean compile：先清理，再执行到compile；\nmvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile；\nmvn clean package：先清理，再执行到package。\n大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。\n经常用到的phase其实只有几个：\n\nclean：清理\ncompile：编译\ntest：运行测试\npackage：打包\n\nGoal执行一个phase又会触发一个或多个goal：\n\n\n\n\n执行的Phase\n对应执行的Goal\n\n\n\n\ncompile\ncompiler:compile\n\n\ntest\ncompiler:testCompile surefire:test\n\n\n\n\ngoal的命名总是abc:xyz这种形式。\n看到这里，相信大家对lifecycle、phase和goal已经明白了吧？\n其实我们类比一下就明白了：\n\nlifecycle相当于Java的package，它包含一个或多个phase；\nphase相当于Java的class，它包含一个或多个goal；\ngoal相当于class的method，它其实才是真正干活的。\n\n大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：\n$ mvn tomcat:run\n小结Maven通过lifecycle、phase和goal来提供标准的构建流程。\n最常用的构建命令是指定phase，然后让Maven执行到指定的phase：\n\nmvn clean\nmvn clean compile\nmvn clean test\nmvn clean package\n\n通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。\n","categories":["Maven"],"tags":["Java,Maven"]},{"title":"Maven模块管理","url":"/2024/11/26/Maven%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/","content":"Maven模块管理在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：\n                        ┌ ─ ─ ─ ─ ─ ─ ┐                          ┌─────────┐                        │ │Module A │ │                          └─────────┘┌──────────────┐ split  │ ┌─────────┐ ││Single Project│───────▶  │Module B │└──────────────┘        │ └─────────┘ │                          ┌─────────┐                        │ │Module C │ │                          └─────────┘                        └ ─ ─ ─ ─ ─ ─ ┘\n\n对于Maven工程来说，原来是一个大项目：\nsingle-project├── pom.xml└── src\n现在可以分拆成3个模块：\nmultiple-projects├── module-a│   ├── pom.xml│   └── src├── module-b│   ├── pom.xml│   └── src└── module-c    ├── pom.xml    └── src\nMaven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml：\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;    &lt;artifactId&gt;module-a&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;module-a&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;        &lt;java.version&gt;11&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.28&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;            &lt;version&gt;5.5.2&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n模块B的pom.xml：\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;    &lt;artifactId&gt;module-b&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;module-b&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;        &lt;java.version&gt;11&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.28&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;            &lt;version&gt;5.5.2&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent：\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;    &lt;artifactId&gt;parent&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;parent&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;        &lt;java.version&gt;11&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.28&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;            &lt;version&gt;5.5.2&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n注意到parent的&lt;packaging&gt;是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：\nmultiple-project├── pom.xml├── parent│   └── pom.xml├── module-a│   ├── pom.xml│   └── src├── module-b│   ├── pom.xml│   └── src└── module-c    ├── pom.xml    └── src\n这样模块A就可以简化为：\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;        &lt;artifactId&gt;parent&lt;/artifactId&gt;        &lt;version&gt;1.0&lt;/version&gt;        &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;    &lt;/parent&gt;    &lt;artifactId&gt;module-a&lt;/artifactId&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;module-a&lt;/name&gt;&lt;/project&gt;\n模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。\n如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：\n...&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;        &lt;artifactId&gt;module-b&lt;/artifactId&gt;        &lt;version&gt;1.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n最后，在编译的时候，需要在根目录创建一个pom.xml统一编译：\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;    &lt;artifactId&gt;build&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;build&lt;/name&gt;    &lt;modules&gt;        &lt;module&gt;parent&lt;/module&gt;        &lt;module&gt;module-a&lt;/module&gt;        &lt;module&gt;module-b&lt;/module&gt;        &lt;module&gt;module-c&lt;/module&gt;    &lt;/modules&gt;&lt;/project&gt;\n这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个&lt;module&gt;，一次性全部编译。\n中央仓库其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。\n私有仓库私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。\n本地仓库本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。\n小结Maven支持模块化管理，可以把一个大项目拆成几个模块：\n\n可以通过继承在parent的pom.xml统一定义重复配置；\n可以通过&lt;modules&gt;编译多个模块。\n\n","categories":["Maven"],"tags":["Maven,Java"]},{"title":"Maven笔记","url":"/2024/11/26/Maven%E7%AC%94%E8%AE%B0/","content":"\n"}]